[
    {
        "Question": "You are working on a binary classification ML algorithm that detects whether an image of a classified scanned document contains a company’s logo. In the dataset, 96% of examples don’t have the logo, so the dataset is very skewed. Which metric would give you the most confidence in your model?",
        "Possible answers": "A)Precision\nB)Recall\nC)RMSE\nD)F1 Score,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The F1 score is the best metric for evaluating the performance of a binary classification model on a skewed dataset. \n\nPrecision measures the proportion of positive predictions that are actually correct, while recall measures the proportion of actual positive examples that are correctly predicted. In a skewed dataset, where the majority of examples belong to the negative class, precision can be very high even if the model is not performing well, simply because it is predicting the majority class most of the time. Recall, on the other hand, can be very low if the model is not able to correctly identify a significant proportion of the positive examples. The F1 score takes both precision and recall into account, and provides a more balanced measure of model performance.\n\nIn this case, the F1 score would give you the most confidence in your model because it would take into account both the precision and recall of the model, and would not be overly influenced by the skewed distribution of the dataset."
    },
    {
        "Question": "You work for a retail company. You have a managed tabular dataset in Vertex AI that contains sales data from three different stores. The dataset includes several features, such as store name and sale timestamp. You want to use the data to train a model that makes sales predictions for a new store that will open soon. You need to split the data between the training, validation, and test sets. What approach should you use to split the data?",
        "Possible answers": "A)Use Vertex AI manual split, using the store name feature to assign one store for each set\nB)Use Vertex AI default data split\nC)Use Vertex AI chronological split, and specify the sales timestamp feature as the time variable\nD)Use Vertex AI random split, assigning 70% of the rows to the training set, 10% to the validation set, and 20% to the test set,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best approach to split the data in this scenario is to use Vertex AI chronological split, and specify the sales timestamp feature as the time variable (option C). This approach ensures that the training, validation, and test sets are temporally ordered, which is important for time series forecasting problems. By using the sales timestamp feature as the time variable, you can ensure that the model is trained on data that is chronologically consistent and can make accurate predictions for future sales.\n\nOption A (manual split using the store name feature) is not suitable because it does not take into account the time component of the data. Simply splitting the data based on store name may result in training, validation, and test sets that are not temporally ordered, which can lead to poor model performance.\n\nOption B (default data split) is also not appropriate because it does not consider the time series nature of the data. The default data split in Vertex AI randomly shuffles the data before splitting it, which can disrupt the temporal order of the sales data and make it difficult for the model to learn the underlying patterns.\n\nOption D (random split) is not ideal because it does not guarantee a consistent distribution of data points across the training, validation, and test sets. Random splitting can result in an uneven distribution of time points, which can affect the model's ability to generalize to new data.\n\nTherefore, the best approach is to use Vertex AI chronological split with the sales timestamp feature as the time variable (option C). This approach ensures that the data is split in a temporally consistent manner, which is crucial for accurate time series forecasting."
    },
    {
        "Question": "You are developing a model to identify traffic signs in images extracted from videos taken from the dashboard of a vehicle. You have a dataset of 100,000 images that were cropped to show one out of ten different traffic signs. The images have been labeled accordingly for model training, and are stored in a Cloud Storage bucket. You need to be able to tune the model during each training run. How should you train the model?",
        "Possible answers": "A)Train a model for object detection by using Vertex AI AutoML.\nB)Train a model for image classification by using Vertex AI AutoML.\nC)Develop the model training code for object detection, and train a model by using Vertex AI custom training.\nD)Develop the model training code for image classification, and train a model by using Vertex AI custom training.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- The dataset contains 100,000 images with 10 different classes, which is a relatively small dataset for object detection.\n- Object detection models require a large amount of data to train well, and AutoML doesn't support object detection.\n- Image classification models are better suited for smaller datasets, and Vertex AI custom training allows for more control over the training process, including hyperparameter tuning."
    },
    {
        "Question": "You are an ML engineer at a manufacturing company. You are creating a classification model for a predictive maintenance use case. You need to predict whether a crucial machine will fail in the next three days so that the repair crew has enough time to fix the machine before it breaks. Regular maintenance of the machine is relatively inexpensive, but a failure would be very costly. You have trained several binary classifiers to predict whether the machine will fail, where a prediction of 1 means that the ML model predicts a failure.You are now evaluating each model on an evaluation dataset. You want to choose a model that prioritizes detection while ensuring that more than 50% of the maintenance jobs triggered by your model address an imminent machine failure. Which model should you choose?",
        "Possible answers": "A)The model with the highest area under the receiver operating characteristic curve (AUC ROC) and precision greater than 0.5\nB)The model with the lowest root mean squared error (RMSE) and recall greater than 0.5.\nC)The model with the highest recall where precision is greater than 0.5.\nD)The model with the highest precision where recall is greater than 0.5.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- AUC-ROC is not a good metric for imbalanced datasets\n- RMSE is not a good metric for classification problems\n- Precision is more important than recall in this case because the cost of a false positive is low, but the cost of a false negative is high.\n- Option C has the highest recall, which means it will catch the most failures, while still maintaining a precision of greater than 0.5, which means that more than 50% of the maintenance jobs triggered by the model will address an imminent machine failure."
    },
    {
        "Question": "You are building a predictive maintenance model to preemptively detect part defects in bridges. You plan to use high definition images of the bridges as model inputs. You need to explain the output of the model to the relevant stakeholders so they can take appropriate action. How should you build the model?",
        "Possible answers": "A)Use scikit-learn to build a tree-based model, and use SHAP values to explain the model output.\nB)Use scikit-learn to build a tree-based model, and use partial dependence plots (PDP) to explain the model output.\nC)Use TensorFlow to create a deep learning-based model, and use Integrated Gradients to explain the model output.\nD)Use TensorFlow to create a deep learning-based model, and use the sampled Shapley method to explain the model output.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- SHAP values are not supported for tree-based models\n- PDPs are not as effective for high-dimensional data\n- Integrated Gradients are a good choice for deep learning models, but can be computationally expensive\n- The sampled Shapley method is a good choice for deep learning models and can handle high-dimensional data"
    },
    {
        "Question": "You are developing a model to help your company create more targeted online advertising campaigns. You need to create a dataset that you will use to train the model. You want to avoid creating or reinforcing unfair bias in the model. What should you do? (Choose two.)",
        "Possible answers": "A)Include a comprehensive set of demographic features\nB)Include only the demographic groups that most frequently interact with advertisements\nC)Collect a random sample of production traffic to build the training dataset\nD)Collect a stratified sample of production traffic to build the training dataset\nE)Conduct fairness tests across sensitive categories and demographics on the trained model,",
        "Correct answer & Explanation": "Correct Answer:\nD and E\n\nExplanation:\n"
    },
    {
        "Question": "You recently deployed an ML model. Three months after deployment, you notice that your model is underperforming on certain subgroups, thus potentially leading to biased results. You suspect that the inequitable performance is due to class imbalances in the training data, but you cannot collect more data. What should you do? (Choose two.)",
        "Possible answers": "A)Remove training examples of high-performing subgroups, and retrain the model.\nB)Add an additional objective to penalize the model more for errors made on the minority class, and retrain the model\nC)Remove the features that have the highest correlations with the majority class.\nD)Upsample or reweight your existing training data, and retrain the model\nE)Redeploy the model, and provide a label explaining the model's behavior to users.,",
        "Correct answer & Explanation": "Correct Answer:\nB and D\n\nExplanation:\n"
    },
    {
        "Question": "You work at a large organization that recently decided to move their ML and data workloads to Google Cloud. The data engineering team has exported the structured data to a Cloud Storage bucket in Avro format. You need to propose a workflow that performs analytics, creates features, and hosts the features that your ML models use for online prediction. How should you configure the pipeline?",
        "Possible answers": "A)Ingest the Avro files into Cloud Spanner to perform analytics. Use a Dataflow pipeline to create the features, and store them in Vertex AI Feature Store for online prediction.\nB)Ingest the Avro files into BigQuery to perform analytics. Use a Dataflow pipeline to create the features, and store them in Vertex AI Feature Store for online prediction.\nC)Ingest the Avro files into Cloud Spanner to perform analytics. Use a Dataflow pipeline to create the features, and store them in BigQuery for online prediction.\nD)Ingest the Avro files into BigQuery to perform analytics. Use BigQuery SQL to create features and store them in a separate BigQuery table for online prediction.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- BigQuery is a better choice for analytics than Cloud Spanner\n- Vertex AI Feature Store is the best choice for storing features for online prediction\n- Dataflow is a good choice for creating features"
    },
    {
        "Question": "You are developing a custom TensorFlow classification model based on tabular data. Your raw data is stored in BigQuery. contains hundreds of millions of rows, and includes both categorical and numerical features. You need to use a MaxMin scaler on some numerical features, and apply a one-hot encoding to some categorical features such as SKU names. Your model will be trained over multiple epochs. You want to minimize the effort and cost of your solution. What should you do?",
        "Possible answers": "A)1. Write a SQL query to create a separate lookup table to scale the numerical features. 2. Deploy a TensorFlow-based model from Hugging Face to BigQuery to encode the text features. 3. Feed the resulting BigQuery view into Vertex AI Training.\nB)1. Use BigQuery to scale the numerical features. 2. Feed the features into Vertex AI Training. 3. Allow TensorFlow to perform the one-hot text encoding.\nC)1. Use TFX components with Dataflow to encode the text features and scale the numerical features. 2. Export results to Cloud Storage as TFRecords. 3. Feed the data into Vertex AI Training.\nD)1. Write a SQL query to create a separate lookup table to scale the numerical features. 2. Perform the one-hot text encoding in BigQuery. 3. Feed the resulting BigQuery view into Vertex AI Training.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- BigQuery can be used to scale numerical features\n- Vertex AI Training can be used to feed the features\n- TensorFlow can perform the one-hot text encoding"
    },
    {
        "Question": "You work for a delivery company. You need to design a system that stores and manages features such as parcels delivered and truck locations over time. The system must retrieve the features with low latency and feed those features into a model for online prediction. The data science team will retrieve historical data at a specific point in time for model training. You want to store the features with minimal effort. What should you do?",
        "Possible answers": "A)Store features in Bigtable as key/value data.\nB)Store features in Vertex AI Feature Store.\nC)Store features as a Vertex AI dataset, and use those features to train the models hosted in Vertex AI endpoints.\nD)Store features in BigQuery timestamp partitioned tables, and use the BigQuery Storage Read API to serve the features.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Bigtable is not a good choice for storing time series data\n- Vertex AI Feature Store is designed for storing and managing features for online prediction\n- Vertex AI dataset is not designed for low latency retrieval\n- BigQuery Storage Read API is not designed for low latency retrieval"
    },
    {
        "Question": "You are an ML engineer at a retail company. You have built a model that predicts a coupon to offer an ecommerce customer at checkout based on the items in their cart. When a customer goes to checkout, your serving pipeline, which is hosted on Google Cloud, joins the customer's existing cart with a row in a BigQuery table that contains the customers' historic purchase behavior and uses that as the model's input. The web team is reporting that your model is returning predictions too slowly to load the coupon offer with the rest of the web page. How should you speed up your model's predictions?",
        "Possible answers": "A)Attach an NVIDIA P100 GPU to your deployed model’s instance.\nB)Use a low latency database for the customers’ historic purchase behavior.\nC)Deploy your model to more instances behind a load balancer to distribute traffic.\nD)Create a materialized view in BigQuery with the necessary data for predictions.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The bottleneck in this scenario is the latency of the database query to retrieve the customer's historic purchase behavior from BigQuery. Using a low latency database, such as Cloud Spanner or Memorystore, for this data would significantly reduce the time it takes to retrieve the data and generate the prediction.\n\nOption A would not help because the model is already deployed on an instance with a GPU.\nOption C would not help because the bottleneck is not the number of instances serving the model, but the latency of the database query.\nOption D would not help because creating a materialized view would not reduce the latency of the database query."
    },
    {
        "Question": "You need to develop a custom TensorFlow model that will be used for online predictions. The training data is stored in BigQuery You need to apply instance-level data transformations to the data for model training and serving. You want to use the same preprocessing routine during model training and serving. How should you configure the preprocessing routine?",
        "Possible answers": "A)Create a BigQuery script to preprocess the data, and write the result to another BigQuery table.\nB)Create a pipeline in Vertex AI Pipelines to read the data from BigQuery and preprocess it using a custom preprocessing component.\nC)Create a preprocessing function that reads and transforms the data from BigQuery. Create a Vertex AI custom prediction routine that calls the preprocessing function at serving time.\nD)Create an Apache Beam pipeline to read the data from BigQuery and preprocess it by using TensorFlow Transform and Dataflow.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Apache Beam is a unified programming model for batch and streaming data processing.\n- TensorFlow Transform is a library for data transformation that can be used with Apache Beam.\n- Dataflow is a managed service for executing Apache Beam pipelines.\n- By using Apache Beam, TensorFlow Transform, and Dataflow, you can create a preprocessing pipeline that can be used for both model training and serving. This will ensure that the same preprocessing routine is applied to the data during both training and serving, which will help to improve the accuracy and consistency of your model."
    },
    {
        "Question": "You recently deployed a model to a Vertex AI endpoint and set up online serving in Vertex AI Feature Store. You have configured a daily batch ingestion job to update your featurestore. During the batch ingestion jobs, you discover that CPU utilization is high in your featurestore’s online serving nodes and that feature retrieval latency is high. You need to improve online serving performance during the daily batch ingestion. What should you do?",
        "Possible answers": "A)Schedule an increase in the number of online serving nodes in your featurestore prior to the batch ingestion jobs\nB)Enable autoscaling of the online serving nodes in your featurestore\nC)Enable autoscaling for the prediction nodes of your DeployedModel in the Vertex AI endpoint\nD)Increase the worker_count in the ImportFeatureValues request of your batch ingestion job,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Autoscaling of online serving nodes in Feature Store can automatically adjust the number of nodes based on traffic, which can help improve performance during batch ingestion jobs.\n- Increasing the number of online serving nodes prior to batch ingestion jobs may not be necessary if autoscaling is enabled.\n- Autoscaling for prediction nodes of the DeployedModel in Vertex AI endpoint is not related to Feature Store online serving performance.\n- Increasing the worker_count in the ImportFeatureValues request of the batch ingestion job may not directly address the issue of high CPU utilization and high feature retrieval latency in online serving nodes."
    },
    {
        "Question": "You work for a semiconductor manufacturing company. You need to create a real-time application that automates the quality control process. High-definition images of each semiconductor are taken at the end of the assembly line in real time. The photos are uploaded to a Cloud Storage bucket along with tabular data that includes each semiconductor’s batch number, serial number, dimensions, and weight. You need to configure model training and serving while maximizing model accuracy. What should you do?",
        "Possible answers": "A)Use Vertex AI Data Labeling Service to label the images, and tram an AutoML image classification model. Deploy the model, and configure Pub/Sub to publish a message when an image is categorized into the failing class.\nB)Use Vertex AI Data Labeling Service to label the images, and train an AutoML image classification model. Schedule a daily batch prediction job that publishes a Pub/Sub message when the job completes.\nC)Convert the images into an embedding representation. Import this data into BigQuery, and train a BigQuery ML K-means clustering model with two clusters. Deploy the model and configure Pub/Sub to publish a message when a semiconductor’s data is categorized into the failing cluster.\nD)Import the tabular data into BigQuery, use Vertex AI Data Labeling Service to label the data and train an AutoML tabular classification model. Deploy the model, and configure Pub/Sub to publish a message when a semiconductor’s data is categorized into the failing class.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- AutoML image classification model is the best choice for image classification tasks.\n- Pub/Sub is used for real-time event notifications.\n- Data Labeling Service can be used to label the images.\n- Batch prediction is not suitable for real-time applications.\n- BigQuery ML K-means clustering is not suitable for image classification tasks.\n- AutoML tabular classification model is not suitable for image classification tasks."
    },
    {
        "Question": "You are using Keras and TensorFlow to develop a fraud detection model. Records of customer transactions are stored in a large table in BigQuery. You need to preprocess these records in a cost-effective and efficient way before you use them to train the model. The trained model will be used to perform batch inference in BigQuery. How should you implement the preprocessing workflow?",
        "Possible answers": "A)Implement a preprocessing pipeline by using Apache Spark, and run the pipeline on Dataproc. Save the preprocessed data as CSV files in a Cloud Storage bucket.\nB)Load the data into a pandas DataFrame. Implement the preprocessing steps using pandas transformations, and train the model directly on the DataFrame.\nC)Perform preprocessing in BigQuery by using SQL. Use the BigQueryClient in TensorFlow to read the data directly from BigQuery.\nD)Implement a preprocessing pipeline by using Apache Beam, and run the pipeline on Dataflow. Save the preprocessed data as CSV files in a Cloud Storage bucket.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best answer is C) Perform preprocessing in BigQuery by using SQL. Use the BigQueryClient in TensorFlow to read the data directly from BigQuery.\n\nHere's why:\n\n- **Cost-effective:** Preprocessing the data in BigQuery eliminates the need for additional data movement or storage costs. BigQuery allows you to perform complex transformations and aggregations on large datasets without the need to load them into memory or a separate processing system.\n\n- **Efficient:** BigQuery is a highly scalable and parallel processing platform. It can process large amounts of data quickly and efficiently, making it suitable for preprocessing tasks that involve filtering, joining, and aggregating data.\n\n- **Direct integration with TensorFlow:** TensorFlow provides the BigQueryClient class that enables you to read data directly from BigQuery into your TensorFlow program. This allows for seamless integration between data preprocessing and model training, reducing the complexity and overhead of managing data pipelines.\n\n- **Batch inference in BigQuery:** Since the trained model will be used for batch inference in BigQuery, it makes sense to perform preprocessing in BigQuery as well. This ensures that the preprocessed data is in the same location and format as required for inference, simplifying the overall workflow.\n\nOption A involves additional data movement and storage costs by saving the preprocessed data as CSV files in Cloud Storage. Option B is not suitable for large datasets as it requires loading the entire dataset into memory. Option D also involves additional data movement and storage costs, and it may not be as efficient as BigQuery for large-scale data preprocessing tasks."
    },
    {
        "Question": "You work for a food product company. Your company’s historical sales data is stored in BigQuery.You need to use Vertex AI’s custom training service to train multiple TensorFlow models that read the data from BigQuery and predict future sales. You plan to implement a data preprocessing algorithm that performs mm-max scaling and bucketing on a large number of features before you start experimenting with the models. You want to minimize preprocessing time, cost, and development effort. How should you configure this workflow?",
        "Possible answers": "A)Write the transformations into Spark that uses the spark-bigquery-connector, and use Dataproc to preprocess the data.\nB)Write SQL queries to transform the data in-place in BigQuery.\nC)Add the transformations as a preprocessing layer in the TensorFlow models.\nD)Create a Dataflow pipeline that uses the BigQuerylO connector to ingest the data, process it, and write it back to BigQuery.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the most efficient way to preprocess data in BigQuery.\n- Spark and Dataflow are not recommended for preprocessing data in BigQuery.\n- Adding transformations as a preprocessing layer in the TensorFlow models is not recommended because it can be inefficient and difficult to maintain."
    },
    {
        "Question": "You want to train an AutoML model to predict house prices by using a small public dataset stored in BigQuery. You need to prepare the data and want to use the simplest, most efficient approach. What should you do?",
        "Possible answers": "A)Write a query that preprocesses the data by using BigQuery and creates a new table. Create a Vertex AI managed dataset with the new table as the data source.\nB)Use Dataflow to preprocess the data. Write the output in TFRecord format to a Cloud Storage bucket.\nC)Write a query that preprocesses the data by using BigQuery. Export the query results as CSV files, and use those files to create a Vertex AI managed dataset.\nD)Use a Vertex AI Workbench notebook instance to preprocess the data by using the pandas library. Export the data as CSV files, and use those files to create a Vertex AI managed dataset.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Option A is the simplest and most efficient approach because it does not require any additional data processing steps.\n- Option B is more complex and requires using Dataflow, which may not be necessary for a small dataset.\n- Option C is also more complex and requires exporting the query results as CSV files, which can be time-consuming for a large dataset.\n- Option D is the most complex and time-consuming approach because it requires using a Vertex AI Workbench notebook instance to preprocess the data."
    },
    {
        "Question": "You are working with a dataset that contains customer transactions. You need to build an ML model to predict customer purchase behavior. You plan to develop the model in BigQuery ML, and export it to Cloud Storage for online prediction. You notice that the input data contains a few categorical features, including product category and payment method. You want to deploy the model as quickly as possible. What should you do?",
        "Possible answers": "A)Use the TRANSFORM clause with the ML.ONE_HOT_ENCODER function on the categorical features at model creation and select the categorical and non-categorical features.\nB)Use the ML.ONE_HOT_ENCODER function on the categorical features and select the encoded categorical features and non-categorical features as inputs to create your model.\nC)Use the CREATE MODEL statement and select the categorical and non-categorical features.\nD)Use the ML.MULTI_HOT_ENCODER function on the categorical features, and select the encoded categorical features and non-categorical features as inputs to create your model.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the best approach because it allows you to explicitly select the encoded categorical features and non-categorical features as inputs to the model. This ensures that the model is trained on the correct features and helps to improve its accuracy.\n- Option A is not recommended because it uses the TRANSFORM clause with the ML.ONE_HOT_ENCODER function, which can be less efficient than using the ML.ONE_HOT_ENCODER function directly.\n- Option C is not recommended because it does not encode the categorical features, which can lead to poor model performance.\n- Option D is not recommended because it uses the ML.MULTI_HOT_ENCODER function, which is not suitable for categorical features with a large number of categories."
    },
    {
        "Question": "You are collaborating on a model prototype with your team. You need to create a Vertex AI Workbench environment for the members of your team and also limit access to other employees in your project. What should you do?",
        "Possible answers": "A)1. Create a new service account and grant it the Notebook Viewer role2. Grant the Service Account User role to each team member on the service account3. Grant the Vertex AI User role to each team member4. Provision a Vertex AI Workbench user-managed notebook instance that uses the new service account\nB)1. Grant the Vertex AI User role to the default Compute Engine service account2. Grant the Service Account User role to each team member on the default Compute Engine service account3. Provision a Vertex AI Workbench user-managed notebook instance that uses the default Compute Engine service account.\nC)1. Create a new service account and grant it the Vertex AI User role2. Grant the Service Account User role to each team member on the service account3. Grant the Notebook Viewer role to each team member. 4. Provision a Vertex AI Workbench user-managed notebook instance that uses the new service account\nD)1. Grant the Vertex AI User role to the primary team member2. Grant the Notebook Viewer role to the other team members3. Provision a Vertex AI Workbench user-managed notebook instance that uses the primary user’s account,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- The Vertex AI User role is required to access Vertex AI Workbench.\n- The Service Account User role is required to impersonate a service account.\n- The Notebook Viewer role is required to view notebooks in Vertex AI Workbench.\n- By creating a new service account and granting it the Vertex AI User role, you can control access to Vertex AI Workbench for your team members.\n- By granting the Service Account User role to each team member on the service account, you can allow them to impersonate the service account and access Vertex AI Workbench.\n- By granting the Notebook Viewer role to each team member, you can allow them to view notebooks in Vertex AI Workbench.\n- By provisioning a Vertex AI Workbench user-managed notebook instance that uses the new service account, you can provide your team members with a secure environment to develop and train models."
    },
    {
        "Question": "You work for a large retailer, and you need to build a model to predict customer chum. The company has a dataset of historical customer data, including customer demographics purchase history, and website activity. You need to create the model in BigQuery ML and thoroughly evaluate its performance. What should you do?",
        "Possible answers": "A)Create a linear regression model in BigQuery ML, and register the model in Vertex AI Model Registry. Evaluate the model performance in Vertex AI .\nB)Create a logistic regression model in BigQuery ML and register the model in Vertex AI Model Registry. Evaluate the model performance in Vertex AI .\nC)Create a linear regression model in BigQuery ML. Use the ML.EVALUATE function to evaluate the model performance.\nD)Create a logistic regression model in BigQuery ML. Use the ML.CONFUSION_MATRIX function to evaluate the model performance.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D) Create a logistic regression model in BigQuery ML. Use the ML.CONFUSION_MATRIX function to evaluate the model performance.\n\n**Explanation:**\n\n- The problem is a binary classification problem (predict customer churn). So, we should use a logistic regression model instead of a linear regression model.\n- The ML.CONFUSION_MATRIX function provides a more comprehensive evaluation of the model performance than the ML.EVALUATE function. It provides a confusion matrix, which shows the number of true positives, false positives, false negatives, and true negatives. This information can be used to calculate various metrics such as accuracy, precision, recall, and F1 score.\n\n**Why other answers are not the best:**\n\n- **A)** is not the best answer because it uses a linear regression model, which is not suitable for binary classification problems.\n- **B)** is not the best answer because it uses the ML.EVALUATE function, which provides less comprehensive evaluation of the model performance compared to the ML.CONFUSION_MATRIX function.\n- **C)** is not the best answer because it does not register the model in Vertex AI Model Registry, which is a best practice for managing and deploying models."
    },
    {
        "Question": "You work for an international manufacturing organization that ships scientific products all over the world. Instruction manuals for these products need to be translated to 15 different languages. Your organization’s leadership team wants to start using machine learning to reduce the cost of manual human translations and increase translation speed. You need to implement a scalable solution that maximizes accuracy and minimizes operational overhead. You also want to include a process to evaluate and fix incorrect translations. What should you do?",
        "Possible answers": "A)Create a workflow using Cloud Function triggers. Configure a Cloud Function that is triggered when documents are uploaded to an input Cloud Storage bucket. Configure another Cloud Function that translates the documents using the Cloud Translation API, and saves the translations to an output Cloud Storage bucket. Use human reviewers to evaluate the incorrect translations.\nB)Create a Vertex AI pipeline that processes the documents launches, an AutoML Translation training job, evaluates the translations and deploys the model to a Vertex AI endpoint with autoscaling and model monitoring. When there is a predetermined skew between training and live data, re-trigger the pipeline with the latest data.\nC)Use AutoML Translation to train a model. Configure a Translation Hub project, and use the trained model to translate the documents. Use human reviewers to evaluate the incorrect translations.\nD)Use Vertex AI custom training jobs to fine-tune a state-of-the-art open source pretrained model with your data. Deploy the model to a Vertex AI endpoint with autoscaling and model monitoring. When there is a predetermined skew between the training and live data, configure a trigger to run another training job with the latest data.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Option A is the best choice because it is the most cost-effective and scalable solution.\n- Cloud Functions are serverless, so you only pay for the resources that you use.\n- You can use Cloud Storage to store the input and output documents, and you can use the Cloud Translation API to translate the documents.\n- Human reviewers can then evaluate the incorrect translations and make corrections.\n- Option B is not as cost-effective as Option A, because you would need to pay for the Vertex AI pipeline, the AutoML Translation training job, and the Vertex AI endpoint.\n- Option C is not as scalable as Option A, because you would need to manually train the AutoML Translation model and deploy it to a Vertex AI endpoint.\n- Option D is not as cost-effective as Option A, because you would need to pay for the Vertex AI custom training job, the Vertex AI endpoint, and the autoscaling and model monitoring."
    },
    {
        "Question": "You are implementing a batch inference ML pipeline in Google Cloud. The model was developed using TensorFlow and is stored in SavedModel format in Cloud Storage. You need to apply the model to a historical dataset containing 10 TB of data that is stored in a BigQuery table. How should you perform the inference?",
        "Possible answers": "A)Export the historical data to Cloud Storage in Avro format. Configure a Vertex AI batch prediction job to generate predictions for the exported data\nB)Import the TensorFlow model by using the CREATE MODEL statement in BigQuery ML. Apply the historical data to the TensorFlow model\nC)Export the historical data to Cloud Storage in CSV format. Configure a Vertex AI batch prediction job to generate predictions for the exported data\nD)Configure a Vertex AI batch prediction job to apply the model to the historical data in BigQuery,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- BigQuery ML supports TensorFlow models through the CREATE MODEL statement.\n- BigQuery ML can directly query data from BigQuery tables, eliminating the need for data export.\n- BigQuery ML can generate predictions for historical data in BigQuery tables.\n- BigQuery ML provides built-in optimization for TensorFlow models, resulting in efficient inference."
    },
    {
        "Question": "You work at an ecommerce startup. You need to create a customer churn prediction model. Your company’s recent sales records are stored in a BigQuery table. You want to understand how your initial model is making predictions. You also want to iterate on the model as quickly as possible while minimizing cost. How should you build your first model?",
        "Possible answers": "A)Export the data to a Cloud Storage bucket. Load the data into a pandas DataFrame on Vertex AI Workbench and train a logistic regression model with scikit-learn.\nB)Create a tf.data.Dataset by using the TensorFlow BigQueryClient. Implement a deep neural network in TensorFlow.\nC)Prepare the data in BigQuery and associate the data with a Vertex AI dataset. Create an AutoMLTabularTrainingJob to tram a classification model.\nD)Export the data to a Cloud Storage bucket. Create a tf.data.Dataset to read the data from Cloud Storage. Implement a deep neural network in TensorFlow.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- AutoML Tables is a good choice for quick iteration and low cost\n- AutoML Tables can be used with BigQuery data\n- AutoML Tables can be used for classification problems"
    },
    {
        "Question": "You work for a company that sells corporate electronic products to thousands of businesses worldwide. Your company stores historical customer data in BigQuery. You need to build a model that predicts customer lifetime value over the next three years. You want to use the simplest approach to build the model and you want to have access to visualization tools. What should you do?",
        "Possible answers": "A)Create a Vertex AI Workbench notebook to perform exploratory data analysis. Use IPython magics to create a new BigQuery table with input features. Use the BigQuery console to run the CREATE MODEL statement. Validate the results by using the ML.EVALUATE and ML.PREDICT statements.\nB)Run the CREATE MODEL statement from the BigQuery console to create an AutoML model. Validate the results by using the ML.EVALUATE and ML.PREDICT statements.\nC)Create a Vertex AI Workbench notebook to perform exploratory data analysis and create input features. Save the features as a CSV file in Cloud Storage. Import the CSV file as a new BigQuery table. Use the BigQuery console to run the CREATE MODEL statement. Validate the results by using the ML.EVALUATE and ML.PREDICT statements.\nD)Create a Vertex AI Workbench notebook to perform exploratory data analysis. Use IPython magics to create a new BigQuery table with input features, create the model, and validate the results by using the CREATE MODEL, ML.EVALUATE, and ML.PREDICT statements.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Option D is the simplest approach because it allows you to perform all the necessary steps, including exploratory data analysis, feature engineering, model creation, and validation, within a single Vertex AI Workbench notebook.\n- IPython magics provide a convenient way to interact with BigQuery and create new tables.\n- The CREATE MODEL statement can be used to create a model directly from a BigQuery table.\n- The ML.EVALUATE and ML.PREDICT statements can be used to validate the model's performance.\n\nOption A is not the best choice because it requires you to use multiple tools (Vertex AI Workbench, IPython magics, BigQuery console) and perform additional steps (creating a new BigQuery table, running the CREATE MODEL statement) that are not necessary with Option D.\n\nOption B is not the best choice because it does not allow you to perform exploratory data analysis or create input features.\n\nOption C is not the best choice because it requires you to save the features as a CSV file in Cloud Storage and import the CSV file as a new BigQuery table, which adds unnecessary complexity and potential for errors."
    },
    {
        "Question": "You need to build classification workflows over several structured datasets currently stored in BigQuery. Because you will be performing the classification several times, you want to complete the following steps without writing code: exploratory data analysis, feature selection, model building, training, and hyperparameter tuning and serving. What should you do?",
        "Possible answers": "A)Train a TensorFlow model on Vertex AI.\nB)Train a classification Vertex AutoML model.\nC)Run a logistic regression job on BigQuery ML.\nD)Use scikit-learn in Vertex AI Workbench user-managed notebooks with pandas library.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Vertex AutoML is a fully managed machine learning service that requires no coding experience.\n- It provides pre-built models for various tasks, including classification, regression, and translation.\n- For structured data stored in BigQuery, Vertex AutoML can automatically generate features and select the best model for the task.\n- This makes it an ideal choice for building classification workflows without writing code.\n\nOther choices are incorrect because:\n\n- Option A requires coding experience to train a TensorFlow model.\n- Option C is limited to running logistic regression models on BigQuery ML.\n- Option D requires coding experience to use scikit-learn in Vertex AI Workbench user-managed notebooks."
    },
    {
        "Question": "You are a data scientist at an industrial equipment manufacturing company. You are developing a regression model to estimate the power consumption in the company’s manufacturing plants based on sensor data collected from all of the plants. The sensors collect tens of millions of records every day. You need to schedule daily training runs for your model that use all the data collected up to the current date. You want your model to scale smoothly and require minimal development work. What should you do?",
        "Possible answers": "A)Develop a custom TensorFlow regression model, and optimize it using Vertex AI Training.\nB)Develop a regression model using BigQuery ML.\nC)Develop a custom scikit-learn regression model, and optimize it using Vertex AI Training.\nD)Develop a custom PyTorch regression model, and optimize it using Vertex AI Training.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- BigQuery ML is a serverless, scalable machine learning service that makes it easy to build, train, and deploy models on massive datasets.\n- BigQuery ML can scale to handle tens of millions of records per day.\n- BigQuery ML requires minimal development work, as it provides a simple SQL-like syntax for building and training models."
    },
    {
        "Question": "You work at a gaming startup that has several terabytes of structured data in Cloud Storage. This data includes gameplay time data, user metadata, and game metadata. You want to build a model that recommends new games to users that requires the least amount of coding. What should you do?",
        "Possible answers": "A)Load the data in BigQuery. Use BigQuery ML to train an Autoencoder model.\nB)Load the data in BigQuery. Use BigQuery ML to train a matrix factorization model.\nC)Read data to a Vertex AI Workbench notebook. Use TensorFlow to train a two-tower model.\nD)Read data to a Vertex AI Workbench notebook. Use TensorFlow to train a matrix factorization model.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Matrix factorization is a technique used for collaborative filtering, which is a common approach for building recommender systems.\n- BigQuery ML provides built-in support for matrix factorization models, making it easy to train and deploy such models without the need for extensive coding.\n- While it is possible to build a two-tower model or use TensorFlow to train a matrix factorization model, these approaches would require more coding and manual effort compared to using BigQuery ML."
    },
    {
        "Question": "You work for a multinational organization that has recently begun operations in Spain. Teams within your organization will need to work with various Spanish documents, such as business, legal, and financial documents. You want to use machine learning to help your organization get accurate translations quickly and with the least effort. Your organization does not require domain-specific terms or jargon. What should you do?",
        "Possible answers": "A)Create a Vertex AI Workbench notebook instance. In the notebook, extract sentences from the documents, and train a custom AutoML text model.\nB)Use Google Translate to translate 1,000 phrases from Spanish to English. Using these translated pairs, train a custom AutoML Translation model.\nC)Use the Document Translation feature of the Cloud Translation API to translate the documents.\nD)Create a Vertex AI Workbench notebook instance. In the notebook, convert the Spanish documents into plain text, and create a custom TensorFlow seq2seq translation model.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best answer is C) Use the Document Translation feature of the Cloud Translation API to translate the documents.\n\nExplanation:\n- The Document Translation feature of the Cloud Translation API is designed specifically for translating large volumes of documents, including business, legal, and financial documents.\n- It uses a combination of statistical machine translation and neural machine translation to provide accurate and fluent translations.\n- It supports a wide range of file formats, including PDF, DOCX, and XLSX.\n- It can be easily integrated with other Google Cloud services, such as Cloud Storage and Cloud Functions, to automate the translation process.\n\nOption A is not the best answer because it requires manual effort to extract sentences from the documents and train a custom AutoML text model.\nOption B is not the best answer because it requires manual effort to translate 1,000 phrases from Spanish to English and train a custom AutoML Translation model.\nOption D is not the best answer because it requires manual effort to convert the Spanish documents into plain text and create a custom TensorFlow seq2seq translation model."
    },
    {
        "Question": "You work at an organization that maintains a cloud-based communication platform that integrates conventional chat, voice, and video conferencing into one platform. The audio recordings are stored in Cloud Storage. All recordings have an 8 kHz sample rate and are more than one minute long. You need to implement a new feature in the platform that will automatically transcribe voice call recordings into a text for future applications, such as call summarization and sentiment analysis. How should you implement the voice call transcription feature following Google-recommended best practices?",
        "Possible answers": "A)Use the original audio sampling rate, and transcribe the audio by using the Speech-to-Text API with synchronous recognition.\nB)Use the original audio sampling rate, and transcribe the audio by using the Speech-to-Text API with asynchronous recognition.\nC)Upsample the audio recordings to 16 kHz, and transcribe the audio by using the Speech-to-Text API with synchronous recognition.\nD)Upsample the audio recordings to 16 kHz, and transcribe the audio by using the Speech-to-Text API with asynchronous recognition.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The best answer is B) Use the original audio sampling rate, and transcribe the audio by using the Speech-to-Text API with asynchronous recognition.\n\nHere's why:\n\n- **Synchronous vs. Asynchronous Recognition**:\n   - Synchronous recognition blocks the calling thread until the transcription is complete, which can be inefficient for long audio recordings.\n   - Asynchronous recognition allows the calling thread to continue execution while the transcription is in progress, making it more efficient for processing multiple audio files concurrently.\n\n- **Audio Sampling Rate**:\n   - The Speech-to-Text API supports audio sampling rates ranging from 8 kHz to 48 kHz.\n   - While upsampling the audio to a higher sampling rate (e.g., 16 kHz) can improve the transcription accuracy in some cases, it also increases the computational cost and may not be necessary for all use cases.\n   - Since the audio recordings already have an 8 kHz sample rate, using the original sampling rate is sufficient for achieving good transcription quality.\n\nTherefore, using the original audio sampling rate (8 kHz) and transcribing the audio using the Speech-to-Text API with asynchronous recognition is the best approach for implementing the voice call transcription feature following Google-recommended best practices."
    },
    {
        "Question": "You are developing a training pipeline for a new XGBoost classification model based on tabular data. The data is stored in a BigQuery table. You need to complete the following steps:1. Randomly split the data into training and evaluation datasets in a 65/35 ratio2. Conduct feature engineering3. Obtain metrics for the evaluation dataset4. Compare models trained in different pipeline executionsHow should you execute these steps?",
        "Possible answers": "A)1. Using Vertex AI Pipelines, add a component to divide the data into training and evaluation sets, and add another component for feature engineering. 2. Enable autologging of metrics in the training component. 3. Compare pipeline runs in Vertex AI Experiments.\nB)1. Using Vertex AI Pipelines, add a component to divide the data into training and evaluation sets, and add another component for feature engineering. 2. Enable autologging of metrics in the training component. 3. Compare models using the artifacts’ lineage in Vertex ML Metadata.\nC)1. In BigQuery ML, use the CREATE MODEL statement with BOOSTED_TREE_CLASSIFIER as the model type and use BigQuery to handle the data splits. 2. Use a SQL view to apply feature engineering and train the model using the data in that view. 3. Compare the evaluation metrics of the models by using a SQL query with the ML.TRAINING_INFO statement.\nD)1. In BigQuery ML, use the CREATE MODEL statement with BOOSTED_TREE_CLASSIFIER as the model type and use BigQuery to handle the data splits. 2. Use ML TRANSFORM to specify the feature engineering transformations and tram the model using the data in the table. 3. Compare the evaluation metrics of the models by using a SQL query with the ML.TRAINING_INFO statement.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Vertex AI Pipelines is the best tool for creating pipelines for machine learning tasks.\n- Autologging of metrics is a feature of Vertex AI Pipelines that makes it easy to track the performance of your models.\n- Vertex AI Experiments is a tool that allows you to compare the performance of different models and pipeline runs."
    },
    {
        "Question": "You work for a social media company. You want to create a no-code image classification model for an iOS mobile application to identify fashion accessories. You have a labeled dataset in Cloud Storage. You need to configure a training workflow that minimizes cost and serves predictions with the lowest possible latency. What should you do?",
        "Possible answers": "A)Train the model by using AutoML, and register the model in Vertex AI Model Registry. Configure your mobile application to send batch requests during prediction.\nB)Train the model by using AutoML Edge, and export it as a Core ML model. Configure your mobile application to use the .mlmodel file directly.\nC)Train the model by using AutoML Edge, and export the model as a TFLite model. Configure your mobile application to use the .tflite file directly.\nD)Train the model by using AutoML, and expose the model as a Vertex AI endpoint. Configure your mobile application to invoke the endpoint during prediction.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- AutoML Edge is designed for on-device inference, so it will have the lowest latency.\n- Core ML is the native framework for iOS, so it will be more efficient than TFLite.\n- Batching requests can increase latency, so it is not ideal for a mobile application.\n- Exposing the model as an endpoint will add additional latency due to network requests."
    },
    {
        "Question": "You are implementing a batch inference ML pipeline in Google Cloud. The model was developed using TensorFlow and is stored in SavedModel format in Cloud Storage. You need to apply the model to a historical dataset containing 10 TB of data that is stored in a BigQuery table. How should you perform the inference?",
        "Possible answers": "A)Export the historical data to Cloud Storage in Avro format. Configure a Vertex AI batch prediction job to generate predictions for the exported data\nB)Import the TensorFlow model by using the CREATE MODEL statement in BigQuery ML. Apply the historical data to the TensorFlow model\nC)Export the historical data to Cloud Storage in CSV format. Configure a Vertex AI batch prediction job to generate predictions for the exported data\nD)Configure a Vertex AI batch prediction job to apply the model to the historical data in BigQuery,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- BigQuery ML supports TensorFlow models through the CREATE MODEL statement.\n- BigQuery ML can directly query data from BigQuery tables, eliminating the need for data export.\n- BigQuery ML can generate predictions for historical data in BigQuery tables.\n- BigQuery ML provides built-in optimization for TensorFlow models, resulting in efficient inference."
    },
    {
        "Question": "You work for a company that is developing an application to help users with meal planning. You want to use machine learning to scan a corpus of recipes and extract each ingredient (e.g., carrot, rice, pasta) and each kitchen cookware (e.g., bowl, pot, spoon) mentioned. Each recipe is saved in an unstructured text file. What should you do?",
        "Possible answers": "A)Create a text dataset on Vertex AI for entity extraction Create two entities called “ingredient” and “cookware”, and label at least 200 examples of each entity. Train an AutoML entity extraction model to extract occurrences of these entity types. Evaluate performance on a holdout dataset.\nB)Create a multi-label text classification dataset on Vertex AI. Create a test dataset, and label each recipe that corresponds to its ingredients and cookware. Train a multi-class classification model. Evaluate the model’s performance on a holdout dataset.\nC)Use the Entity Analysis method of the Natural Language API to extract the ingredients and cookware from each recipe. Evaluate the model's performance on a prelabeled dataset.\nD)Create a text dataset on Vertex AI for entity extraction. Create as many entities as there are different ingredients and cookware. Train an AutoML entity extraction model to extract those entities. Evaluate the model’s performance on a holdout dataset.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- AutoML entity extraction is the best choice for extracting structured data from unstructured text.\n- Option B is not a good choice because it requires labeling each recipe with all of its ingredients and cookware, which would be very time-consuming.\n- Option C is not a good choice because it is not as accurate as AutoML entity extraction.\n- Option D is not a good choice because it would require creating a very large number of entities, which would make the model difficult to train and use."
    },
    {
        "Question": "You work for a retail company. You have been tasked with building a model to determine the probability of churn for each customer. You need the predictions to be interpretable so the results can be used to develop marketing campaigns that target at-risk customers. What should you do?",
        "Possible answers": "A)Build a random forest regression model in a Vertex AI Workbench notebook instance. Configure the model to generate feature importances after the model is trained.\nB)Build an AutoML tabular regression model. Configure the model to generate explanations when it makes predictions.\nC)Build a custom TensorFlow neural network by using Vertex AI custom training. Configure the model to generate explanations when it makes predictions.\nD)Build a random forest classification model in a Vertex AI Workbench notebook instance. Configure the model to generate feature importances after the model is trained.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n AutoML tabular regression models can generate explanations when they make predictions, making them interpretable and suitable for developing marketing campaigns that target at-risk customers. Random forest models, while interpretable through feature importances, are not specifically designed for regression tasks and may not provide the best accuracy for predicting churn probability. Custom TensorFlow neural networks can be configured to generate explanations, but they require more expertise to build and may not be necessary for this specific task. Random forest classification models are not suitable for predicting probabilities and should be used for classification tasks instead."
    },
    {
        "Question": "You work at a leading healthcare firm developing state-of-the-art algorithms for various use cases. You have unstructured textual data with custom labels. You need to extract and classify various medical phrases with these labels. What should you do?",
        "Possible answers": "A)Use the Healthcare Natural Language API to extract medical entities\nB)Use a BERT-based model to fine-tune a medical entity extraction model\nC)Use AutoML Entity Extraction to train a medical entity extraction model\nD)Use TensorFlow to build a custom medical entity extraction model,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n AutoML Entity Extraction is a cloud service that allows you to train and deploy custom entity extraction models without the need for extensive machine learning expertise. It provides a user-friendly interface and requires minimal code, making it a suitable choice for extracting and classifying medical phrases with custom labels.\n\nHere's why other options are not the best choices:\n\nA) The Healthcare Natural Language API is designed for extracting specific medical entities such as conditions, medications, and procedures. It may not be suitable for extracting custom labels that are not part of its predefined entities.\n\nB) While BERT-based models are powerful for natural language processing tasks, fine-tuning a BERT model for medical entity extraction requires significant expertise in machine learning and data preparation. It can be time-consuming and may not be feasible for those without extensive machine learning knowledge.\n\nD) Building a custom medical entity extraction model using TensorFlow requires a deep understanding of machine learning algorithms, data preprocessing techniques, and model optimization. It is a complex and time-consuming process that may not be practical for those without extensive machine learning expertise."
    },
    {
        "Question": "You work for a hotel and have a dataset that contains customers’ written comments scanned from paper-based customer feedback forms, which are stored as PDF files. Every form has the same layout. You need to quickly predict an overall satisfaction score from the customer comments on each form. How should you accomplish this task?",
        "Possible answers": "A)Use the Vision API to parse the text from each PDF file. Use the Natural Language API analyzeSentiment feature to infer overall satisfaction scores.\nB)Use the Vision API to parse the text from each PDF file. Use the Natural Language API analyzeEntitySentiment feature to infer overall satisfaction scores.\nC)Uptrain a Document AI custom extractor to parse the text in the comments section of each PDF file. Use the Natural Language API analyzeSentiment feature to infer overall satisfaction scores.\nD)Uptrain a Document AI custom extractor to parse the text in the comments section of each PDF file. Use the Natural Language API analyzeEntitySentiment feature to infer overall satisfaction scores.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Document AI is used to parse text from documents\n- AnalyzeSentiment is used to determine the sentiment of the text"
    },
    {
        "Question": "You work for a company that captures live video footage of checkout areas in their retail stores. You need to use the live video footage to build a model to detect the number of customers waiting for service in near real time. You want to implement a solution quickly and with minimal effort. How should you build the model?",
        "Possible answers": "A)Use the Vertex AI Vision Occupancy Analytics model.\nB)Use the Vertex AI Vision Person/vehicle detector model.\nC)Train an AutoML object detection model on an annotated dataset by using Vertex AutoML.\nD)Train a Seq2Seq+ object detection model on an annotated dataset by using Vertex AutoML.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n The best answer is A) Use the Vertex AI Vision Occupancy Analytics model.\n\nThe Vertex AI Vision Occupancy Analytics model is a pre-trained model that can be used to detect the number of people in a given area. This model is specifically designed for use with live video footage, and it can be deployed quickly and easily with minimal effort.\n\nThe other options are not as good because they require more effort and/or are not as accurate. Option B) requires you to train a custom model, which can be time-consuming and expensive. Option C) requires you to annotate a dataset, which can also be time-consuming and expensive. Option D) is not as accurate as the other options."
    },
    {
        "Question": "Your company stores a large number of audio files of phone calls made to your customer call center in an on-premises database. Each audio file is in wav format and is approximately 5 minutes long. You need to analyze these audio files for customer sentiment. You plan to use the Speech-to-Text API You want to use the most efficient approach. What should you do?",
        "Possible answers": "A)1. Upload the audio files to Cloud Storage2. Call the speech:longrunningrecognize API endpoint to generate transcriptions3. Call the predict method of an AutoML sentiment analysis model to analyze the transcriptions.\nB)1. Upload the audio files to Cloud Storage. 2. Call the speech:longrunningrecognize API endpoint to generate transcriptions3. Create a Cloud Function that calls the Natural Language API by using the analyzeSentiment method\nC)1. Iterate over your local files in Python2. Use the Speech-to-Text Python library to create a speech.RecognitionAudio object, and set the content to the audio file data3. Call the speech:recognize API endpoint to generate transcriptions4. Call the predict method of an AutoML sentiment analysis model to analyze the transcriptions.\nD)1. Iterate over your local files in Python2. Use the Speech-to-Text Python Library to create a speech.RecognitionAudio object and set the content to the audio file data3. Call the speech:longrunningrecognize API endpoint to generate transcriptions. 4. Call the Natural Language API by using the analyzeSentiment method,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the most efficient because it uses the long-running recognize API, which allows you to transcribe audio files asynchronously. This means that you don't have to wait for the transcriptions to be generated before you can start analyzing them.\n- Option A is less efficient because it uses the synchronous recognize API, which means that you have to wait for the transcriptions to be generated before you can start analyzing them.\n- Option C is less efficient because it requires you to iterate over your local files in Python and create a speech.RecognitionAudio object for each file. This can be time-consuming if you have a large number of files.\n- Option D is less efficient because it requires you to call the Natural Language API by using the analyzeSentiment method for each transcription. This can be time-consuming if you have a large number of transcriptions."
    },
    {
        "Question": "You work for a pet food company that manages an online forum. Customers upload photos of their pets on the forum to share with others. About 20 photos are uploaded daily. You want to automatically and in near real time detect whether each uploaded photo has an animal. You want to prioritize time and minimize cost of your application development and deployment. What should you do?",
        "Possible answers": "A)Send user-submitted images to the Cloud Vision API. Use object localization to identify all objects in the image and compare the results against a list of animals.\nB)Download an object detection model from TensorFlow Hub. Deploy the model to a Vertex AI endpoint. Send new user-submitted images to the model endpoint to classify whether each photo has an animal.\nC)Manually label previously submitted images with bounding boxes around any animals. Build an AutoML object detection model by using Vertex AI. Deploy the model to a Vertex AI endpoint Send new user-submitted images to your model endpoint to detect whether each photo has an animal.\nD)Manually label previously submitted images as having animals or not. Create an image dataset on Vertex AI. Train a classification model by using Vertex AutoML to distinguish the two classes. Deploy the model to a Vertex AI endpoint. Send new user-submitted images to your model endpoint to classify whether each photo has an animal.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Cloud Vision API is a pre-trained model that can be used for object detection, including animals.\n- It is a cost-effective solution since you only pay for the API calls you make.\n- It is also a scalable solution since you can easily increase or decrease the number of API calls you make as needed.\n- The other options require more time and effort to implement and may not be as cost-effective."
    },
    {
        "Question": "You need to develop an image classification model by using a large dataset that contains labeled images in a Cloud Storage bucket. What should you do?",
        "Possible answers": "A)Use Vertex AI Pipelines with the Kubeflow Pipelines SDK to create a pipeline that reads the images from Cloud Storage and trains the model.\nB)Use Vertex AI Pipelines with TensorFlow Extended (TFX) to create a pipeline that reads the images from Cloud Storage and trains the model.\nC)Import the labeled images as a managed dataset in Vertex AI and use AutoML to train the model.\nD)Convert the image dataset to a tabular format using Dataflow Load the data into BigQuery and use BigQuery ML to train the model.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- AutoML is a good choice for image classification problems\n- AutoML can handle large datasets\n- AutoML can be used with Vertex AI Pipelines"
    },
    {
        "Question": "You work for an auto insurance company. You are preparing a proof-of-concept ML application that uses images of damaged vehicles to infer damaged parts. Your team has assembled a set of annotated images from damage claim documents in the company’s database. The annotations associated with each image consist of a bounding box for each identified damaged part and the part name. You have been given a sufficient budget to train models on Google Cloud. You need to quickly create an initial model. What should you do?",
        "Possible answers": "A)Download a pre-trained object detection model from TensorFlow Hub. Fine-tune the model in Vertex AI Workbench by using the annotated image data.\nB)Train an object detection model in AutoML by using the annotated image data.\nC)Create a pipeline in Vertex AI Pipelines and configure the AutoMLTrainingJobRunOp component to train a custom object detection model by using the annotated image data.\nD)Train an object detection model in Vertex AI custom training by using the annotated image data.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- AutoML is a good choice for quick prototyping\n- AutoML is a good choice for small datasets\n- AutoML is a good choice for non-experts"
    },
    {
        "Question": "You work for a hospital that wants to optimize how it schedules operations. You need to create a model that uses the relationship between the number of surgeries scheduled and beds used. You want to predict how many beds will be needed for patients each day in advance based on the scheduled surgeries. You have one year of data for the hospital organized in 365 rows.The data includes the following variables for each day:• Number of scheduled surgeries• Number of beds occupied• DateYou want to maximize the speed of model development and testing. What should you do?",
        "Possible answers": "A)Create a BigQuery table. Use BigQuery ML to build a regression model, with number of beds as the target variable, and number of scheduled surgeries and date features (such as day of week) as the predictors.\nB)Create a BigQuery table. Use BigQuery ML to build an ARIMA model, with number of beds as the target variable, and date as the time variable.\nC)Other option\nD)Create a Vertex AI tabular dataset. Train an AutoML regression model, with number of beds as the target variable, and number of scheduled minor surgeries and date features (such as day of the week) as the predictors.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- AutoML Tables is the fastest way to build and deploy models\n- AutoML Tables can handle time series data\n- AutoML Tables can handle categorical data"
    },
    {
        "Question": "You created a model that uses BigQuery ML to perform linear regression. You need to retrain the model on the cumulative data collected every week. You want to minimize the development effort and the scheduling cost. What should you do",
        "Possible answers": "A)Use BigQuery’s scheduling service to run the model retraining query periodically.\nB)Create a pipeline in Vertex AI Pipelines that executes the retraining query, and use the Cloud Scheduler API to run the query weekly.\nC)Use Cloud Scheduler to trigger a Cloud Function every week that runs the query for retraining the model.\nD)Use the BigQuery API Connector and Cloud Scheduler to trigger Workflows every week that retrains the model.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- BigQuery ML has a built-in scheduling service that can be used to run the model retraining query periodically.\n- This eliminates the need to create and manage a separate pipeline or Cloud Function, reducing development effort and scheduling cost.\n- Option B requires creating a pipeline in Vertex AI Pipelines, which adds complexity and cost.\n- Option C requires creating a Cloud Function, which also adds complexity and cost.\n- Option D requires using the BigQuery API Connector and Cloud Scheduler to trigger Workflows, which is more complex and costly than using BigQuery's built-in scheduling service."
    },
    {
        "Question": "You work for an online retailer. Your company has a few thousand short lifecycle products. Your company has five years of sales data stored in BigQuery. You have been asked to build a model that will make monthly sales predictions for each product. You want to use a solution that can be implemented quickly with minimal effort. What should you do?",
        "Possible answers": "A)Use Prophet on Vertex AI Training to build a custom model.\nB)Use Vertex AI Forecast to build a NN-based model.\nC)Use BigQuery ML to build a statistical ARIMA_PLUS model.\nD)Use TensorFlow on Vertex AI Training to build a custom model.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Prophet is not a good choice for short lifecycle products\n- NN-based models require a lot of data and can be complex to build\n- TensorFlow requires a lot of code and can be complex to build\n- BigQuery ML is a good choice for time series forecasting and can be implemented quickly with minimal effort"
    },
    {
        "Question": "You are developing a model to detect fraudulent credit card transactions. You need to prioritize detection, because missing even one fraudulent transaction could severely impact the credit card holder. You used AutoML to tram a model on users' profile information and credit card transaction data After training the initial model, you notice that the model is failing to detect many fraudulent transactions. How should you adjust the training parameters in AutoML to improve model performance? (Choose two.)",
        "Possible answers": "A)Increase the score threshold\nB)Decrease the score threshold.\nC)Add more positive examples to the training set\nD)Add more negative examples to the training set\nE)Reduce the maximum number of node hours for training,",
        "Correct answer & Explanation": "Correct Answer:\nB and C\n\nExplanation:\n"
    },
    {
        "Question": "You are training a custom language model for your company using a large dataset. You plan to use the Reduction Server strategy on Vertex AI.You need to configure the worker pools of the distributed training job. What should you do?",
        "Possible answers": "A)Configure the machines of the first two worker pools to have GPUs, and to use a container image where your training code runs. Configurethe third worker pool to have GPUs, and use the reductionserver container image.\nB)Configure the machines of the first two worker pools to have GPUs and to use a container image where your training code runs. Configure the third worker pool to use the reductionserver container image without accelerators, and choose a machine type that prioritizes bandwidth.\nC)Configure the machines of the first two worker pools to have TPUs and to use a container image where your training code runs. Configure the third worker pool without accelerators, and use the reductionserver container image without accelerators, and choose a machine type thatprioritizes bandwidth.\nD)Configure the machines of the first two pools to have TPUs, and to use a container image where your training code runs. Configure the thirdpool to have TPUs, and use the reductionserver container image.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n - Use the reduction server on NVIDIA so no need for TPU's\n- Option B doesn't use GPU's on the third pool with the reduction server"
    },
    {
        "Question": "You are training models in Vertex AI by using data that spans across multiple Google Cloud projects. You need to find, track, and compare the performance of the different versions of your models. Which Google Cloud services should you include in your ML workflow?",
        "Possible answers": "A)Dataplex, Vertex AI Feature Store, and Vertex AI TensorBoard\nB)Vertex AI Pipelines, Vertex AI Feature Store, and Vertex AI Experiments\nC)Dataplex, Vertex AI Experiments, and Vertex AI ML Metadata\nD)Vertex AI Pipelines, Vertex AI Experiments, and Vertex AI Metadata,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n - Vertex AI Pipelines is used to track and compare the performance of different versions of your models.\n- Vertex AI Experiments is used to find and track the different versions of your models.\n- Vertex AI Metadata is used to store the metadata of your models."
    },
    {
        "Question": "Your team is training a large number of ML models that use different algorithms, parameters, and datasets. Some models are trained in Vertex AI Pipelines, and some are trained on Vertex AI Workbench notebook instances. Your team wants to compare the performance of the models across both services. You want to minimize the effort required to store the parameters and metrics. What should you do?",
        "Possible answers": "A)Implement an additional step for all the models running in pipelines and notebooks to export parameters and metrics to BigQuery.\nB)Create a Vertex AI experiment. Submit all the pipelines as experiment runs. For models trained on notebooks log parameters and metrics by using the Vertex AI SDK.\nC)Implement all models in Vertex AI Pipelines Create a Vertex AI experiment, and associate all pipeline runs with that experiment.\nD)Store all model parameters and metrics as model metadata by using the Vertex AI Metadata API.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the best because it allows for easy comparison of models trained in both Vertex AI Pipelines and Vertex AI Workbench notebook instances.\n- By creating a Vertex AI experiment and submitting all the pipelines as experiment runs, you can easily track and compare the performance of all the models in one place.\n- For models trained on notebooks, you can use the Vertex AI SDK to log parameters and metrics, which will be automatically stored in the experiment.\n- This way, you can easily compare the performance of models trained in both services without having to implement additional steps or store the parameters and metrics separately."
    },
    {
        "Question": "You developed a Transformer model in TensorFlow to translate text. Your training data includes millions of documents in a Cloud Storage bucket. You plan to use distributed training to reduce training time. You need to configure the training job while minimizing the effort required to modify code and to manage the cluster’s configuration. What should you do?",
        "Possible answers": "A)Create a Vertex AI custom training job with GPU accelerators for the second worker pool. Use tf.distribute.MultiWorkerMirroredStrategy for distribution.\nB)Create a Vertex AI custom distributed training job with Reduction Server. Use N1 high-memory machine type instances for the first and second pools, and use N1 high-CPU machine type instances for the third worker pool.\nC)Create a training job that uses Cloud TPU VMs. Use tf.distribute.TPUStrategy for distribution.\nD)Create a Vertex AI custom training job with a single worker pool of A2 GPU machine type instances. Use tf.distribute.MirroredStrategv for distribution.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- TPU's are best for transformer models\n- TPUStrategy is the best strategy for TPU's"
    },
    {
        "Question": "You are developing a recommendation engine for an online clothing store. The historical customer transaction data is stored in BigQuery and Cloud Storage. You need to perform exploratory data analysis (EDA), preprocessing and model training. You plan to rerun these EDA, preprocessing, and training steps as you experiment with different types of algorithms. You want to minimize the cost and development effort of running these steps as you experiment. How should you configure the environment?",
        "Possible answers": "A)Create a Vertex AI Workbench user-managed notebook using the default VM instance, and use the %%bigquerv magic commands in Jupyter to query the tables.\nB)Create a Vertex AI Workbench managed notebook to browse and query the tables directly from the JupyterLab interface.\nC)Create a Vertex AI Workbench user-managed notebook on a Dataproc Hub, and use the %%bigquery magic commands in Jupyter to query the tables.\nD)Create a Vertex AI Workbench managed notebook on a Dataproc cluster, and use the spark-bigquery-connector to access,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the best choice because it allows you to browse and query the tables directly from the JupyterLab interface, which is convenient and efficient.\n- Option A requires you to use the %%bigquery magic commands in Jupyter, which can be less convenient and may require additional setup.\n- Option C requires you to create a Dataproc Hub, which can be more complex and time-consuming to set up.\n- Option D requires you to use the spark-bigquery-connector, which may require additional setup and configuration."
    },
    {
        "Question": "You work for a startup that has multiple data science workloads. Your compute infrastructure is currently on-premises, and the data science workloads are native to PySpark. Your team plans to migrate their data science workloads to Google Cloud. You need to build a proof of concept to migrate one data science job to Google Cloud. You want to propose a migration process that requires minimal cost and effort. What should you do first?",
        "Possible answers": "A)Create a n2-standard-4 VM instance and install Java, Scala, and Apache Spark dependencies on it.\nB)Create a Google Kubernetes Engine cluster with a basic node pool configuration, install Java, Scala, and Apache Spark dependencies on it.\nC)Create a Standard (1 master, 3 workers) Dataproc cluster, and run a Vertex AI Workbench notebook instance on it.\nD)Create a Vertex AI Workbench notebook with instance type n2-standard-4.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D: Create a Vertex AI Workbench notebook with instance type n2-standard-4.\n\nExplanation:\nVertex AI Workbench is a fully managed development environment for machine learning. It provides a Jupyter notebook interface with pre-installed libraries and tools for machine learning, including PySpark. By creating a Vertex AI Workbench notebook with instance type n2-standard-4, you can quickly and easily set up a development environment for your data science job without having to install any dependencies or manage infrastructure.\n\nOption A is not the best answer because it requires you to manually install Java, Scala, and Apache Spark dependencies on the VM instance, which can be time-consuming and error-prone.\n\nOption B is not the best answer because it requires you to create and manage a Google Kubernetes Engine cluster, which can be more complex and expensive than using Vertex AI Workbench.\n\nOption C is not the best answer because it requires you to create a Dataproc cluster, which is a managed Spark cluster service, but it does not provide a Jupyter notebook interface like Vertex AI Workbench."
    },
    {
        "Question": "You have trained a DNN regressor with TensorFlow to predict housing prices using a set of predictive features. Your default precision is tf.float64, and you use a standard TensorFlow estimator. Your model performs well, but just before deploying it to production, you discover that your current serving latency is 10ms @ 90 percentile and you currently serve on CPUs. Your production requirements expect a model latency of 8ms @ 90 percentile. You're willing to accept a small decrease in performance in order to reach the latency requirement.Therefore your plan is to improve latency while evaluating how much the model's prediction decreases. What should you first try to quickly lower the serving latency?",
        "Possible answers": "A)Switch from CPU to GPU serving.\nB)Apply quantization to your SavedModel by reducing the floating point precision to tf.float16.\nC)Increase the dropout rate to 0.8 and retrain your model.\nD)Increase the dropout rate to 0.8 in _PREDICT mode by adjusting the TensorFlow Serving parameters.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\nQuantization is a technique used to reduce the size of a model by reducing the precision of its weights and activations. This can lead to faster inference times, as the model can be processed more quickly on hardware that supports lower precision. In this case, reducing the precision from tf.float64 to tf.float16 can potentially reduce the serving latency without significantly affecting the model's performance.\n\nWhile switching from CPU to GPU serving can also improve latency, it may require more infrastructure changes and may not be as straightforward as applying quantization. Increasing the dropout rate may help reduce overfitting and improve generalization, but it is unlikely to have a significant impact on serving latency. Adjusting the TensorFlow Serving parameters to increase the dropout rate in _PREDICT mode may also help reduce latency, but it is not as effective as quantization in this scenario."
    },
    {
        "Question": "You built a custom ML model using scikit-learn. Training time is taking longer than expected. You decide to migrate your model to Vertex AI Training, and you want to improve the model’s training time. What should you try out first?",
        "Possible answers": "A)Train your model in a distributed mode using multiple Compute Engine VMs.\nB)Train your model using Vertex AI Training with CPUs.\nC)Migrate your model to TensorFlow, and train it using Vertex AI Training.\nD)Train your model using Vertex AI Training with GPUs.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- CPUs are generally faster than GPUs for training scikit-learn models.\n- Distributed training is not supported for scikit-learn models in Vertex AI Training.\n- TensorFlow is not required for training scikit-learn models in Vertex AI Training."
    },
    {
        "Question": "You work for a bank. You have been asked to develop an ML model that will support loan application decisions. You need to determine which Vertex AI services to include in the workflow. You want to track the model’s training parameters and the metrics per training epoch. You plan to compare the performance of each version of the model to determine the best model based on your chosen metrics. Which Vertex AI services should you use?",
        "Possible answers": "A)Vertex ML Metadata, Vertex AI Feature Store, and Vertex AI Vizier\nB)Vertex AI Pipelines, Vertex AI Experiments, and Vertex AI Vizier\nC)Vertex ML Metadata, Vertex AI Experiments, and Vertex AI TensorBoard\nD)Vertex AI Pipelines, Vertex AI Feature Store, and Vertex AI TensorBoard,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Vertex ML Metadata stores training parameters and metrics\n- Vertex AI Experiments tracks model versions and compares performance\n- Vertex AI TensorBoard visualizes metrics"
    },
    {
        "Question": "You are training models in Vertex AI by using data that spans across multiple Google Cloud projects. You need to find, track, and compare the performance of the different versions of your models. Which Google Cloud services should you include in your ML workflow?",
        "Possible answers": "A)Dataplex, Vertex AI Feature Store, and Vertex AI TensorBoard\nB)Vertex AI Pipelines, Vertex AI Feature Store, and Vertex AI Experiments\nC)Dataplex, Vertex AI Experiments, and Vertex AI ML Metadata\nD)Vertex AI Pipelines, Vertex AI Experiments, and Vertex AI Metadata,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n - Vertex AI Pipelines is used to track and compare the performance of different versions of your models.\n- Vertex AI Experiments is used to track and compare the performance of different versions of your models.\n- Vertex AI Metadata is used to find and track the different versions of your models."
    },
    {
        "Question": "You are developing an ML model to identify your company’s products in images. You have access to over one million images in a Cloud Storage bucket. You plan to experiment with different TensorFlow models by using Vertex AI Training. You need to read images at scale during training while minimizing data I/O bottlenecks. What should you do?",
        "Possible answers": "A)Load the images directly into the Vertex AI compute nodes by using Cloud Storage FUSE. Read the images by using the tf.data.Dataset.from_tensor_slices function\nB)Create a Vertex AI managed dataset from your image data. Access the AIP_TRAINING_DATA_URI environment variable to read the images by using the tf.data.Dataset.list_files function.\nC)Convert the images to TFRecords and store them in a Cloud Storage bucket. Read the TFRecords by using the tf.data.TFRecordDataset function.\nD)Store the URLs of the images in a CSV file. Read the file by using the tf.data.experimental.CsvDataset function.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- TFRecords is a binary file format that is specifically designed for storing data for machine learning.\n- TFRecords can be read efficiently using the tf.data.TFRecordDataset function, which allows for parallel processing and prefetching of data.\n- Using TFRecords can significantly reduce data I/O bottlenecks during training, especially when working with large datasets.\n- Options A and B require reading images directly from Cloud Storage or a managed dataset, which can be slower and less efficient.\n- Option D involves reading a CSV file, which is not as efficient as TFRecords for storing and reading image data."
    },
    {
        "Question": "You manage a team of data scientists who use a cloud-based backend system to submit training jobs. This system has become very difficult to administer, and you want to use a managed service instead. The data scientists you work with use many different frameworks, including Keras, PyTorch, theano, scikit-learn, and custom libraries. What should you do?",
        "Possible answers": "A)Use the Vertex AI Training to submit training jobs using any framework.\nB)Configure Kubeflow to run on Google Kubernetes Engine and submit training jobs through TFJob.\nC)Create a library of VM images on Compute Engine, and publish these images on a centralized repository.\nD)Set up Slurm workload manager to receive jobs that can be scheduled to run on your cloud infrastructure.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Vertex AI Training supports all the frameworks mentioned in the question.\n- Kubeflow only supports TensorFlow.\n- Compute Engine doesn't support all the frameworks mentioned in the question.\n- Slurm workload manager doesn't support all the frameworks mentioned in the question."
    },
    {
        "Question": "You have recently developed a custom model for image classification by using a neural network. You need to automatically identify the values for learning rate, number of layers, and kernel size. To do this, you plan to run multiple jobs in parallel to identify the parameters that optimize performance. You want to minimize custom code development and infrastructure management. What should you do?",
        "Possible answers": "A)Train an AutoML image classification model.\nB)Create a custom training job that uses the Vertex AI Vizier SDK for parameter optimization.\nC)Create a Vertex AI hyperparameter tuning job.\nD)Create a Vertex AI pipeline that runs different model training jobs in parallel.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- AutoML is a managed service that doesn't allow for parameter tuning\n- Custom training jobs require custom code\n- Pipelines run jobs sequentially, not in parallel\n- Hyperparameter tuning jobs allow for parallel execution of training jobs with different parameters"
    },
    {
        "Question": "You have a custom job that runs on Vertex AI on a weekly basis. The job is implemented using a proprietary ML workflow that produces the datasets, models, and custom artifacts, and sends them to a Cloud Storage bucket. Many different versions of the datasets and models were created. Due to compliance requirements, your company needs to track which model was used for making a particular prediction, and needs access to the artifacts for each model. How should you configure your workflows to meet these requirements?",
        "Possible answers": "A)Use the Vertex AI Metadata API inside the custom job to create context, execution, and artifacts for each model, and use events to link them together.\nB)Create a Vertex AI experiment, and enable autologging inside the custom job.\nC)Configure a TensorFlow Extended (TFX) ML Metadata database, and use the ML Metadata API.\nD)Register each model in Vertex AI Model Registry, and use model labels to store the related dataset and model information.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Question:\nYou have a custom job that runs on Vertex AI on a weekly basis. The job is implemented using a proprietary ML workflow that produces the datasets, models, and custom artifacts, and sends them to a Cloud Storage bucket. Many different versions of the datasets and models were created. Due to compliance requirements, your company needs to track which model was used for making a particular prediction, and needs access to the artifacts for each model. How should you configure your workflows to meet these requirements?\n\nChoices:\nA) Use the Vertex AI Metadata API inside the custom job to create context, execution, and artifacts for each model, and use events to link them together.\nB) Create a Vertex AI experiment, and enable autologging inside the custom job.\nC) Configure a TensorFlow Extended (TFX) ML Metadata database, and use the ML Metadata API.\nD) Register each model in Vertex AI Model Registry, and use model labels to store the related dataset and model information.\n\nCorrect Answer:\nA)\n\nExplanation:\n- Vertex AI Metadata API is used to track lineage and artifacts\n- Autologging is not used for custom jobs\n- TFX is not used for custom jobs\n- Model Registry is not used to track lineage"
    },
    {
        "Question": "You need to train an XGBoost model on a small dataset. Your training code requires custom dependencies. You want to minimize the startup time of your training job. How should you set up your Vertex AI custom training job?",
        "Possible answers": "A)Store the data in a Cloud Storage bucket, and create a custom container with your training application. In your training application, read the data from Cloud Storage and train the model.\nB)Use the XGBoost prebuilt custom container. Create a Python source distribution that includes the data and installs the dependencies at runtime. In your training application, load the data into a pandas DataFrame and train the model.\nC)Create a custom container that includes the data. In your training application, load the data into a pandas DataFrame and train the model.\nD)Store the data in a Cloud Storage bucket, and use the XGBoost prebuilt custom container to run your training application. Create a Python source distribution that installs the dependencies at runtime. In your training application, read the data from Cloud Storage and train the model.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Custom container allows for custom dependencies\n- Reading from Cloud Storage is faster than loading data into a pandas DataFrame"
    },
    {
        "Question": "You work for a rapidly growing social media company. Your team builds TensorFlow recommender models in an on-premises CPU cluster. The data contains billions of historical user events and 100,000 categorical features. You notice that as the data increases, the model training time increases. You plan to move the models to Google Cloud. You want to use the most scalable approach that also minimizes training time. What should you do?",
        "Possible answers": "A)Deploy the training jobs by using TPU VMs with TPUv3 Pod slices, and use the TPUEmbeading API\nB)Deploy the training jobs in an autoscaling Google Kubernetes Engine cluster with CPUs\nC)Deploy a matrix factorization model training job by using BigQuery ML\nD)Deploy the training jobs by using Compute Engine instances with A100 GPUs, and use the tf.nn.embedding_lookup API,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n - TPUv3 Pod slices are the most scalable option for training large recommender models.\n- TPUEmbedding API is designed for large-scale embedding training.\n- Autoscaling Google Kubernetes Engine cluster with CPUs is not as scalable as TPUv3 Pod slices.\n- BigQuery ML is not suitable for training large recommender models.\n- Compute Engine instances with A100 GPUs are not as scalable as TPUv3 Pod slices.\n- tf.nn.embedding_lookup API is not as efficient as TPUEmbedding API for large-scale embedding training."
    },
    {
        "Question": "You are developing an ML model in a Vertex AI Workbench notebook. You want to track artifacts and compare models during experimentation using different approaches. You need to rapidly and easily transition successful experiments to production as you iterate on your model implementation. What should you do?",
        "Possible answers": "A)1. Initialize the Vertex SDK with the name of your experiment. Log parameters and metrics for each experiment, and attach dataset and model artifacts as inputs and outputs to each execution. 2. After a successful experiment create a Vertex AI pipeline.\nB)1. Initialize the Vertex SDK with the name of your experiment. Log parameters and metrics for each experiment, save your dataset to a Cloud Storage bucket, and upload the models to Vertex AI Model Registry. 2. After a successful experiment, create a Vertex AI pipeline.\nC)1. Create a Vertex AI pipeline with parameters you want to track as arguments to your PipelineJob. Use the Metrics, Model, and Dataset artifact types from the Kubeflow Pipelines DSL as the inputs and outputs of the components in your pipeline. 2. Associate the pipeline with your experiment when you submit the job.\nD)1. Create a Vertex AI pipeline. Use the Dataset and Model artifact types from the Kubeflow Pipelines DSL as the inputs and outputs of the components in your pipeline. 2. In your training component, use the Vertex AI SDK to create an experiment run. Configure the log_params and log_metrics functions to track parameters and metrics of your experiment.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Option A uses the Vertex SDK to log parameters and metrics, and attach dataset and model artifacts as inputs and outputs to each execution. This allows for easy tracking and comparison of models during experimentation.\n- Option B involves saving the dataset to a Cloud Storage bucket and uploading models to Vertex AI Model Registry, which is not necessary for tracking artifacts within an experiment.\n- Option C requires creating a Vertex AI pipeline with parameters as arguments to the PipelineJob, which is not as flexible as using the Vertex SDK to log parameters and metrics.\n- Option D involves creating a Vertex AI pipeline and using the Vertex AI SDK to create an experiment run within the training component, which is more complex and requires additional code compared to Option A."
    },
    {
        "Question": "You are developing a model to predict whether a failure will occur in a critical machine part. You have a dataset consisting of a multivariate time series and labels indicating whether the machine part failed. You recently started experimenting with a few different preprocessing and modeling approaches in a Vertex AI Workbench notebook. You want to log data and track artifacts from each run. How should you set up your experiments?",
        "Possible answers": "A)1. Use the Vertex AI SDK to create an experiment and set up Vertex ML Metadata. 2. Use the log_time_series_metrics function to track the preprocessed data, and use the log_merrics function to log loss values.\nB)1. Use the Vertex AI SDK to create an experiment and set up Vertex ML Metadata. 2. Use the log_time_series_metrics function to track the preprocessed data, and use the log_metrics function to log loss values.\nC)1. Create a Vertex AI TensorBoard instance and use the Vertex AI SDK to create an experiment and associate the TensorBoard instance. 2. Use the assign_input_artifact method to track the preprocessed data and use the log_time_series_metrics function to log loss values.\nD)1. Create a Vertex AI TensorBoard instance, and use the Vertex AI SDK to create an experiment and associate the TensorBoard instance. 2. Use the log_time_series_metrics function to track the preprocessed data, and use the log_metrics function to log loss values,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Tensorboard is used for tracking metrics and artifacts\n- Assign_input_artifact is used to track preprocessed data"
    },
    {
        "Question": "You are developing a process for training and running your custom model in production. You need to be able to show lineage for your model and predictions. What should you do?",
        "Possible answers": "A)1. Create a Vertex AI managed dataset. 2. Use a Vertex AI training pipeline to train your model. 3. Generate batch predictions in Vertex AI.\nB)1. Use a Vertex AI Pipelines custom training job component to tram your model. 2. Generate predictions by using a Vertex AI Pipelines model batch predict component.\nC)1. Upload your dataset to BigQuery. 2. Use a Vertex AI custom training job to train your model. 3. Generate predictions by using Vertex Al SDK custom prediction routines.\nD)1. Use Vertex AI Experiments to train your model. 2. Register your model in Vertex AI Model Registry. 3. Generate batch predictions in Vertex AI.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Question:\nYou are developing a process for training and running your custom model in production. You need to be able to show lineage for your model and predictions.\nWhat should you do?\n\nChoices:\nA) 1. Create a Vertex AI managed dataset.\n2. Use a Vertex AI training pipeline to train your model.\n3. Generate batch predictions in Vertex AI.\n\nB) 1. Use a Vertex AI Pipelines custom training job component to train your model.\n2. Generate predictions by using a Vertex AI Pipelines model batch predict component.\n\nC) 1. Upload your dataset to BigQuery.\n2. Use a Vertex AI custom training job to train your model.\n3. Generate predictions by using Vertex AI SDK custom prediction routines.\n\nD) 1. Use Vertex AI Experiments to train your model.\n2. Register your model in Vertex AI Model Registry.\n3. Generate batch predictions in Vertex AI.\n\nCorrect Answer:\nB)\n\nExplanation:\n- Vertex AI Pipelines provides built-in lineage tracking, making it easy to trace the origin of your data, models, and predictions.\n- Custom training job component allows you to train your model using your own custom code and configurations.\n- Model batch predict component enables you to generate batch predictions from your trained model."
    },
    {
        "Question": "You are working on a prototype of a text classification model in a managed Vertex AI Workbench notebook. You want to quickly experiment with tokenizing text by using a Natural Language Toolkit (NLTK) library. How should you add the library to your Jupyter kernel?",
        "Possible answers": "A)Install the NLTK library from a terminal by using the pip install nltk command.\nB)Write a custom Dataflow job that uses NLTK to tokenize your text and saves the output to Cloud Storage.\nC)Create a new Vertex AI Workbench notebook with a custom image that includes the NLTK library.\nD)Install the NLTK library from a Jupyter cell by using the !pip install nltk --user command.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D) because it allows you to quickly and easily install the NLTK library directly from a Jupyter cell without having to leave the notebook environment or create a custom image. This is particularly useful when you are experimenting with different libraries and want to avoid the overhead of creating a new custom image for each experiment.\n\nAnswer A) is not the best choice because it requires you to install the library from a terminal, which takes you out of the notebook environment and can be more time-consuming.\n\nAnswer B) is not the best choice because it involves creating a custom Dataflow job, which is more complex and time-consuming than simply installing the library from a Jupyter cell.\n\nAnswer C) is not the best choice because it requires you to create a new custom image with the NLTK library included, which can be more time-consuming and may not be necessary if you only need the library for a quick experiment."
    },
    {
        "Question": "You work with a team of researchers to develop state-of-the-art algorithms for financial analysis. Your team develops and debugs complex models in TensorFlow. You want to maintain the ease of debugging while also reducing the model training time. How should you set up your training environment?",
        "Possible answers": "A)Configure a v3-8 TPU VM. SSH into the VM to train and debug the model.\nB)Configure a v3-8 TPU node. Use Cloud Shell to SSH into the Host VM to train and debug the model.\nC)Configure a n1 -standard-4 VM with 4 NVIDIA P100 GPUs. SSH into the VM and use ParameterServerStraregv to train the model.\nD)Configure a n1-standard-4 VM with 4 NVIDIA P100 GPUs. SSH into the VM and use MultiWorkerMirroredStrategy to train the model.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- MultiWorkerMirroredStrategy is the best choice for synchronous training on multiple GPUs.\n- ParameterServerStrategy is used for asynchronous training on multiple GPUs.\n- Cloud Shell is not recommended for training models.\n- TPUs are not recommended for training small models."
    },
    {
        "Question": "You want to migrate a scikit-learn classifier model to TensorFlow. You plan to train the TensorFlow classifier model using the same training set that was used to train the scikit-learn model, and then compare the performances using a common test set. You want to use the Vertex AI Python SDK to manually log the evaluation metrics of each model and compare them based on their F1 scores and confusion matrices. How should you log the metrics?",
        "Possible answers": "A)Use the aiplatform.log_classification_metrics function to log the F1 score, and use the aiplatform.log_metrics function to log the confusion matrix.\nB)Use the aiplatform.log_classification_metrics function to log the F1 score and the confusion matrix.\nC)Use the aiplatform.log_metrics function to log the F1 score and the confusion matrix.\nD)Use the aiplatform.log_metrics function to log the F1 score: and use the aiplatform.log_classification_metrics function to log the confusion matrix.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The correct answer is D) Use the aiplatform.log_metrics function to log the F1 score: and use the aiplatform.log_classification_metrics function to log the confusion matrix.\n\nExplanation:\n- The aiplatform.log_classification_metrics function is used to log classification metrics such as accuracy, precision, recall, F1 score, and confusion matrix.\n- The aiplatform.log_metrics function is used to log general metrics such as loss, accuracy, and latency.\n- In this case, we want to log both the F1 score and the confusion matrix, so we should use both functions."
    },
    {
        "Question": "You work on a team that builds state-of-the-art deep learning models by using the TensorFlow framework. Your team runs multiple ML experiments each week, which makes it difficult to track the experiment runs. You want a simple approach to effectively track, visualize, and debug ML experiment runs on Google Cloud while minimizing any overhead code. How should you proceed?",
        "Possible answers": "A)Set up Vertex AI Experiments to track metrics and parameters. Configure Vertex AI TensorBoard for visualization.\nB)Set up a Cloud Function to write and save metrics files to a Cloud Storage bucket. Configure a Google Cloud VM to host TensorBoard locally for visualization.\nC)Set up a Vertex AI Workbench notebook instance. Use the instance to save metrics data in a Cloud Storage bucket and to host TensorBoard locally for visualization.\nD)Set up a Cloud Function to write and save metrics files to a BigQuery table. Configure a Google Cloud VM to host TensorBoard locally for visualization,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Question:\nYou work on a team that builds state-of-the-art deep learning models by using the TensorFlow framework. Your team runs multiple ML experiments each week, which makes it difficult to track the experiment runs. You want a simple approach to effectively track, visualize, and debug ML experiment runs on Google Cloud while minimizing any overhead code. How should you proceed?\n\nChoices:\nA) Set up Vertex AI Experiments to track metrics and parameters. Configure Vertex AI TensorBoard for visualization.\nB) Set up a Cloud Function to write and save metrics files to a Cloud Storage bucket. Configure a Google Cloud VM to host TensorBoard locally for visualization.\nC) Set up a Vertex AI Workbench notebook instance. Use the instance to save metrics data in a Cloud Storage bucket and to host TensorBoard locally for visualization.\nD) Set up a Cloud Function to write and save metrics files to a BigQuery table. Configure a Google Cloud VM to host TensorBoard locally for visualization.\n\nCorrect Answer:\nA)\n\nExplanation:\nVertex AI Experiments is a purpose-built service for tracking, visualizing, and debugging ML experiment runs on Google Cloud. It provides a simple and intuitive user interface, and it integrates with other Vertex AI services, such as Vertex AI TensorBoard, to provide a comprehensive ML development environment.\n\nOption B requires setting up a Cloud Function and a Google Cloud VM, which adds unnecessary complexity and overhead. Option C requires setting up a Vertex AI Workbench notebook instance, which is more expensive than using Vertex AI Experiments. Option D requires setting up a Cloud Function and a BigQuery table, which adds unnecessary complexity and overhead."
    },
    {
        "Question": "You have created a Vertex AI pipeline that automates custom model training. You want to add a pipeline component that enables your team to most easily collaborate when running different executions and comparing metrics both visually and programmatically. What should you do?",
        "Possible answers": "A)Add a component to the Vertex AI pipeline that logs metrics to a BigQuery table. Query the table to compare different executions of the pipeline. Connect BigQuery to Looker Studio to visualize metrics.\nB)Add a component to the Vertex AI pipeline that logs metrics to a BigQuery table. Load the table into a pandas DataFrame to compare different executions of the pipeline. Use Matplotlib to visualize metrics.\nC)Add a component to the Vertex AI pipeline that logs metrics to Vertex ML Metadata. Use Vertex AI Experiments to compare different executions of the pipeline. Use Vertex AI TensorBoard to visualize metrics.\nD)Add a component to the Vertex AI pipeline that logs metrics to Vertex ML Metadata. Load the Vertex ML Metadata into a pandas DataFrame to compare different executions of the pipeline. Use Matplotlib to visualize metrics.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Vertex AI Experiments is a tool for comparing different executions of a pipeline.\n- Vertex AI TensorBoard is a tool for visualizing metrics.\n- Vertex ML Metadata is a service for storing and managing metadata about machine learning models.\n- BigQuery is a cloud data warehouse that can be used to store and query data.\n- Looker Studio is a data visualization tool that can be used to create interactive dashboards and reports.\n- Pandas is a Python library for data analysis and manipulation.\n- Matplotlib is a Python library for creating static, interactive, and animated visualizations.\n\nIn this case, the best way to add a pipeline component that enables your team to most easily collaborate when running different executions and comparing metrics both visually and programmatically is to add a component to the Vertex AI pipeline that logs metrics to Vertex ML Metadata. This will allow your team to use Vertex AI Experiments to compare different executions of the pipeline and Vertex AI TensorBoard to visualize metrics."
    },
    {
        "Question": "You are investigating the root cause of a misclassification error made by one of your models. You used Vertex AI Pipelines to train and deploy the model. The pipeline reads data from BigQuery. creates a copy of the data in Cloud Storage in TFRecord format, trains the model in Vertex AI Training on that copy, and deploys the model to a Vertex AI endpoint. You have identified the specific version of that model that misclassified, and you need to recover the data this model was trained on. How should you find that copy of the data?",
        "Possible answers": "A)Use Vertex AI Feature Store. Modify the pipeline to use the feature store, and ensure that all training data is stored in it. Search the feature store for the data used for the training.\nB)Use the lineage feature of Vertex AI Metadata to find the model artifact. Determine the version of the model and identify the step that creates the data copy and search in the metadata for its location.\nC)Use the logging features in the Vertex AI endpoint to determine the timestamp of the model’s deployment. Find the pipeline run at that timestamp. Identify the step that creates the data copy, and search in the logs for its location.\nD)Find the job ID in Vertex AI Training corresponding to the training for the model. Search in the logs of that job for the data used for the training.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The best answer is B) because Vertex AI Metadata provides lineage information that allows you to trace the origin of the model and its associated data. By determining the version of the model and identifying the step that creates the data copy, you can search in the metadata for the location of the data used for training. This approach provides a direct and efficient way to recover the specific data copy used for the model that made the misclassification error.\n\nOption A) is not the best answer because it suggests modifying the pipeline to use Vertex AI Feature Store, which may not be necessary or feasible in this scenario. While Feature Store can be useful for managing features, it may not have been used in the original pipeline.\n\nOption C) is not the best answer because it relies on logging features in the Vertex AI endpoint, which may not provide the necessary information about the data used for training. The logs may contain deployment-related information, but they may not explicitly capture the details of the training data.\n\nOption D) is not the best answer because it involves searching through the logs of the Vertex AI Training job, which may be time-consuming and may not provide the exact location of the data copy. The lineage information in Vertex AI Metadata offers a more direct and structured way to find the data."
    },
    {
        "Question": "You need to use TensorFlow to train an image classification model. Your dataset is located in a Cloud Storage directory and contains millions of labeled images. Before training the model, you need to prepare the data. You want the data preprocessing and model training workflow to be as efficient, scalable, and low maintenance as possible. What should you do?",
        "Possible answers": "A)1. Create a Dataflow job that creates sharded TFRecord files in a Cloud Storage directory. 2. Reference tf.data.TFRecordDataset in the training script. 3. Train the model by using Vertex AI Training with a V100 GPU.\nB)1. Create a Dataflow job that moves the images into multiple Cloud Storage directories, where each directory is named according to the corresponding label2. Reference tfds.folder_dataset:ImageFolder in the training script. 3. Train the model by using Vertex AI Training with a V100 GPU.\nC)1. Create a Jupyter notebook that uses an nt-standard-64 V100 GPU Vertex AI Workbench instance. 2. Write a Python script that creates sharded TFRecord files in a directory inside the instance. 3. Reference tf.data.TFRecordDataset in the training script. 4. Train the model by using the Workbench instance.\nD)1. Create a Jupyter notebook that uses an n1-standard-64, V100 GPU Vertex AI Workbench instance. 2. Write a Python script that copies the images into multiple Cloud Storage directories, where each. directory is named according to the corresponding label. 3. Reference tfds.foladr_dataset.ImageFolder in the training script. 4. Train the model by using the Workbench instance.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Option A uses Dataflow to create sharded TFRecord files, which is the recommended approach for large datasets.\n- Option B uses ImageFolder, which is not recommended for large datasets.\n- Option C involves unnecessary data copying and is not as efficient as Option A.\n- Option D uses ImageFolder, which is not recommended for large datasets."
    },
    {
        "Question": "You are pre-training a large language model on Google Cloud. This model includes custom TensorFlow operations in the training loop. Model training will use a large batch size, and you expect training to take several weeks. You need to configure a training architecture that minimizes both training time and compute costs. What should you do?",
        "Possible answers": "A)Implement 8 workers of a2-megagpu-16g machines by using tf.distribute.MultiWorkerMirroredStrategy.\nB)Implement a TPU Pod slice with -accelerator-type=v4-l28 by using tf.distribute.TPUStrategy.\nC)Implement 16 workers of c2d-highcpu-32 machines by using tf.distribute.MirroredStrategy.\nD)Implement 16 workers of a2-highgpu-8g machines by using tf.distribute.MultiWorkerMirroredStrategy.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- TPU's are the best option for large batch sizes\n- TPU's are the most cost effective option for large batch sizes\n- TPU's are the fastest option for large batch sizes"
    },
    {
        "Question": "You are training an ML model on a large dataset. You are using a TPU to accelerate the training process. You notice that the training process is taking longer than expected. You discover that the TPU is not reaching its full capacity. What should you do?",
        "Possible answers": "A)Increase the learning rate\nB)Increase the number of epochs\nC)Decrease the learning rate\nD)Increase the batch size,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\nIncreasing the batch size can help improve TPU utilization and reduce training time. TPUs are designed to process large batches of data efficiently, and increasing the batch size allows more data to be processed in each iteration, leading to faster convergence.\n\nIncreasing the learning rate can potentially speed up training, but it may also lead to instability and decreased accuracy. Increasing the number of epochs may not be effective if the model is already not converging within the current number of epochs. Decreasing the learning rate can slow down training even further."
    },
    {
        "Question": "You created an ML pipeline with multiple input parameters. You want to investigate the tradeoffs between different parameter combinations. The parameter options are• Input dataset• Max tree depth of the boosted tree regressor• Optimizer learning rateYou need to compare the pipeline performance of the different parameter combinations measured in F1 score, time to train, and model complexity. You want your approach to be reproducible, and track all pipeline runs on the same platform. What should you do?",
        "Possible answers": "A)1. Use BigQueryML to create a boosted tree regressor, and use the hyperparameter tuning capability. 2. Configure the hyperparameter syntax to select different input datasets: max tree depths, and optimizer learning rates. Choose the grid search option.\nB)1. Create a Vertex AI pipeline with a custom model training job as part of the pipeline. Configure the pipeline’s parameters to include those you are investigating. 2. In the custom training step, use the Bayesian optimization method with F1 score as the target to maximize.\nC)1. Create a Vertex AI Workbench notebook for each of the different input datasets. 2. In each notebook, run different local training jobs with different combinations of the max tree depth and optimizer learning rate parameters. 3. After each notebook finishes, append the results to a BigQuery table.\nD)1. Create an experiment in Vertex AI Experiments. 2. Create a Vertex AI pipeline with a custom model training job as part of the pipeline. Configure the pipeline’s parameters to include those you are investigating. 3. Submit multiple runs to the same experiment, using different values for the parameters.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Vertex AI Experiments is the best tool to compare multiple runs of a pipeline with different parameters.\n- It allows for easy tracking and comparison of different runs, and provides visualizations and metrics to help you analyze the results.\n- Vertex AI Experiments also allows you to easily reproduce runs and share them with others."
    },
    {
        "Question": "You recently developed a wide and deep model in TensorFlow. You generated training datasets using a SQL script that preprocessed raw data inBigQuery by performing instance-level transformations of the data. You need to create a training pipeline to retrain the model on a weekly basis.The trained model will be used to generate daily recommendations. You want to minimize model development and training time. How should youdevelop the training pipeline?",
        "Possible answers": "A)Use the Kubeflow Pipelines SDK to implement the pipeline. Use the BigQueryJobOp component to run the preprocessing script and theCustomTrainingJobOp component to launch a Vertex AI training job.\nB)Use the Kubeflow Pipelines SDK to implement the pipeline. Use the DataflowPythonJobOp component to preprocess the data and the CustomTrainingJobOp component to launch a Vertex AI training job.\nC)Use the TensorFlow Extended SDK to implement the pipeline Use the ExampleGen component with the BigQuery executor to ingest the data the Transform component to preprocess the data, and the Trainer component to launch a Vertex AI training job.\nD)Use the TensorFlow Extended SDK to implement the pipeline Implement the preprocessing steps as part of the input_fn of the model. Usethe ExampleGen component with the BigQuery executor to ingest the data and the Trainer component to launch a Vertex AI training job.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n - Wide & deep models are used for recommendation engines\n- Google doesn't recommend using input_fn\n- Examplegen ingests data from BQ and generates train and evaluation components"
    },
    {
        "Question": "You trained a model packaged it with a custom Docker container for serving, and deployed it to Vertex AI Model Registry. When you submit a batch prediction job, it fails with this error: \"Error model server never became ready. Please validate that your model file or container configuration are valid. \" There are no additional errors in the logs. What should you do?",
        "Possible answers": "A)Add a logging configuration to your application to emit logs to Cloud Logging\nB)Change the HTTP port in your model’s configuration to the default value of 8080\nC)Change the healthRoute value in your model’s configuration to /healthcheck\nD)Pull the Docker image locally, and use the docker run command to launch it locally. Use the docker logs command to explore the error logs,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best way to debug a model server issue is to run it locally and check the logs. This allows you to reproduce the issue and investigate the root cause without having to deal with the complexities of a remote environment. By pulling the Docker image locally and using the docker run command, you can easily start the model server and use the docker logs command to view the error logs. This will provide you with valuable information about the issue and help you identify the necessary steps to resolve it.\n\nOption A is not the best choice because adding a logging configuration may not provide additional insights into the root cause of the issue. While logs can be helpful, they may not always contain the specific details needed to diagnose the problem.\n\nOption B is not the best choice because changing the HTTP port to the default value of 8080 may not resolve the issue. The error message indicates a more fundamental problem with the model server, and changing the port is unlikely to fix it.\n\nOption C is not the best choice because changing the healthRoute value to /healthcheck may not address the underlying issue. The healthRoute value is used for health checks, but it does not directly affect the model server's ability to process batch prediction requests."
    },
    {
        "Question": "You developed a Vertex AI pipeline that trains a classification model on data stored in a large BigQuery table. The pipeline has four steps, where each step is created by a Python function that uses the KubeFlow v2 API. You perform many model iterations by adjusting the code and parameters of the training step. You observe high costs associated with the development, particularly the data export and preprocessing steps. You need to reduce model development costs. What should you do?",
        "Possible answers": "A)Change the components’ YAML filenames to export.yaml, preprocess,yaml, f \"train-{dt}.yaml\", f\"calibrate-{dt).vaml\".\nB)Add the {\"kubeflow.v1.caching\": True} parameter to the set of params provided to your PipelineJob.\nC)Move the first step of your pipeline to a separate step, and provide a cached path to Cloud Storage as an input to the main pipeline.\nD)Change the name of the pipeline to f\"my-awesome-pipeline-{dt}\".,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B enables caching for the pipeline, which means that the intermediate results of the pipeline will be stored in Cloud Storage and reused across pipeline runs, reducing the cost of data export and preprocessing.\n- Option A does not affect the cost of the pipeline.\n- Option C does not reduce the cost of data export and preprocessing.\n- Option D does not affect the cost of the pipeline."
    },
    {
        "Question": "You are building a custom image classification model and plan to use Vertex AI Pipelines to implement the end-to-end training. Your dataset consists of images that need to be preprocessed before they can be used to train the model. The preprocessing steps include resizing the images, converting them to grayscale, and extracting features. You have already implemented some Python functions for the preprocessing tasks. Which components should you use in your pipeline?",
        "Possible answers": "A)DataprocSparkBatchOp and CustomTrainingJobOp\nB)DataflowPythonJobOp, WaitGcpResourcesOp, and CustomTrainingJobOp\nC)dsl.ParallelFor, dsl.component, and CustomTrainingJobOp\nD)ImageDatasetImportDataOp, dsl.component, and AutoMLImageTrainingJobRunOp,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- DataflowPythonJobOp can be used to preprocess data in parallel\n- WaitGcpResourcesOp can be used to wait for the preprocessing job to complete before starting the training job\n- CustomTrainingJobOp can be used to launch a Vertex AI training job"
    },
    {
        "Question": "You are developing an ML model that predicts the cost of used automobiles based on data such as location, condition, model type, color, and engine/battery efficiency. The data is updated every night. Car dealerships will use the model to determine appropriate car prices. You created a Vertex AI pipeline that reads the data splits the data into training/evaluation/test sets performs feature engineering trains the model by using the training dataset and validates the model by using the evaluation dataset. You need to configure a retraining workflow that minimizes cost. What should you do?",
        "Possible answers": "A)Compare the training and evaluation losses of the current run. If the losses are similar, deploy the model to a Vertex AI endpoint. Configure a cron job to redeploy the pipeline every night.\nB)Compare the training and evaluation losses of the current run. If the losses are similar, deploy the model to a Vertex AI endpoint with training/serving skew threshold model monitoring. When the model monitoring threshold is triggered redeploy the pipeline.\nC)Compare the results to the evaluation results from a previous run. If the performance improved deploy the model to a Vertex AI endpoint. Configure a cron job to redeploy the pipeline every night.\nD)Compare the results to the evaluation results from a previous run. If the performance improved deploy the model to a Vertex AI endpoint with training/serving skew threshold model monitoring. When the model monitoring threshold is triggered redeploy the pipeline.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Option D is the best choice because it compares the results to the evaluation results from a previous run and deploys the model to a Vertex AI endpoint with training/serving skew threshold model monitoring. This ensures that the model is retrained only when the performance improves, minimizing cost.\n- Option A is not the best choice because it does not compare the results to the evaluation results from a previous run. This could lead to deploying a model that does not perform well.\n- Option B is not the best choice because it does not compare the results to the evaluation results from a previous run. This could lead to deploying a model that does not perform well.\n- Option C is not the best choice because it does not deploy the model to a Vertex AI endpoint with training/serving skew threshold model monitoring. This could lead to deploying a model that does not perform well."
    },
    {
        "Question": "You recently trained a XGBoost model that you plan to deploy to production for online inference. Before sending a predict request to your model’s binary, you need to perform a simple data preprocessing step. This step exposes a REST API that accepts requests in your internal VPC Service Controls and returns predictions. You want to configure this preprocessing step while minimizing cost and effort. What should you do?",
        "Possible answers": "A)Store a pickled model in Cloud Storage. Build a Flask-based app, package the app in a custom container image, and deploy the model to Vertex AI Endpoints.\nB)Build a Flask-based app, package the app and a pickled model in a custom container image, and deploy the model to Vertex AI Endpoints.\nC)Build a custom predictor class based on XGBoost Predictor from the Vertex AI SDK, package it and a pickled model in a custom container image based on a Vertex built-in image, and deploy the model to Vertex AI Endpoints.\nD)Build a custom predictor class based on XGBoost Predictor from the Vertex AI SDK, and package the handler in a custom container image based on a Vertex built-in container image. Store a pickled model in Cloud Storage, and deploy the model to Vertex AI Endpoints.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Option D is the most cost-effective and requires the least effort.\n- By using a custom predictor class based on the XGBoost Predictor from the Vertex AI SDK, you can easily integrate your preprocessing step with the model.\n- By packaging the handler in a custom container image based on a Vertex built-in image, you can leverage the pre-built infrastructure and security features of Vertex AI.\n- By storing the pickled model in Cloud Storage, you can ensure that the model is accessible to the endpoint."
    },
    {
        "Question": "You work as an analyst at a large banking firm. You are developing a robust scalable ML pipeline to train several regression and classification models. Your primary focus for the pipeline is model interpretability. You want to productionize the pipeline as quickly as possible. What should you do?",
        "Possible answers": "A)Use Tabular Workflow for Wide & Deep through Vertex AI Pipelines to jointly train wide linear models and deep neural networks\nB)Use Google Kubernetes Engine to build a custom training pipeline for XGBoost-based models\nC)Use Tabular Workflow for TabNet through Vertex AI Pipelines to train attention-based models\nD)Use Cloud Composer to build the training pipelines for custom deep learning-based models,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n TabNet is a type of neural network that is specifically designed for tabular data. It is an attention-based model, which means that it can learn to focus on the most important features in the data. This makes it a good choice for interpretability, as it is easier to understand how the model is making predictions. Additionally, Tabular Workflow is a tool that makes it easy to build and deploy machine learning pipelines on Vertex AI. This can help you to productionize your pipeline quickly and easily."
    },
    {
        "Question": "Your company manages an ecommerce website. You developed an ML model that recommends additional products to users in near real time based on items currently in the user’s cart. The workflow will include the following processes:\t1. The website will send a Pub/Sub message with the relevant data and then receive a message with the prediction from Pub/Sub 2. Predictions will be stored in BigQuery3. The model will be stored in a Cloud Storage bucket and will be updated frequentlyYou want to minimize prediction latency and the effort required to update the model. How should you reconfigure the architecture?",
        "Possible answers": "A)Write a Cloud Function that loads the model into memory for prediction. Configure the function to be triggered when messages are sent to Pub/Sub.\nB)Create a pipeline in Vertex AI Pipelines that performs preprocessing, prediction, and postprocessing. Configure the pipeline to be triggered by a Cloud Function when messages are sent to Pub/Sub.\nC)Expose the model as a Vertex AI endpoint. Write a custom DoFn in a Dataflow job that calls the endpoint for prediction.\nD)Use the RunInference API with WatchFilePattern in a Dataflow job that wraps around the model and serves predictions.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D) Use the RunInference API with WatchFilePattern in a Dataflow job that wraps around the model and serves predictions.\n\nHere's why:\n\n- The RunInference API provides a low-latency, scalable way to serve predictions from a machine learning model.\n- WatchFilePattern allows the Dataflow job to automatically detect and load new versions of the model from Cloud Storage, ensuring that the predictions are always up-to-date.\n- By wrapping the model in a Dataflow job, you can easily scale the prediction service to handle increased traffic.\n\nHere's why the other answers are not as good:\n\n- A) Writing a Cloud Function to load the model into memory for prediction would introduce additional latency and complexity to the architecture.\n- B) Creating a pipeline in Vertex AI Pipelines would require more effort to set up and manage than using the RunInference API.\n- C) Exposing the model as a Vertex AI endpoint would require additional infrastructure and configuration, and would not provide the same level of scalability as using the RunInference API."
    },
    {
        "Question": "You have recently used TensorFlow to train a classification model on tabular data. You have created a Dataflow pipeline that can transform several terabytes of data into training or prediction datasets consisting of TFRecords. You now need to productionize the model, and you want the predictions to be automatically uploaded to a BigQuery table on a weekly schedule. What should you do?",
        "Possible answers": "A)Import the model into Vertex AI and deploy it to a Vertex AI endpoint. On Vertex AI Pipelines, create a pipeline that uses the DataflowPythonJobOp and the ModelBacthPredictOp components.\nB)Import the model into Vertex AI and deploy it to a Vertex AI endpoint. Create a Dataflow pipeline that reuses the data processing logic sends requests to the endpoint, and then uploads predictions to a BigQuery table.\nC)Import the model into Vertex AI. On Vertex AI Pipelines, create a pipeline that uses the DataflowPvthonJobOp and the ModelBatchPredictOp components.\nD)Import the model into BigQuery. Implement the data processing logic in a SQL query. On Vertex AI Pipelines create a pipeline that uses the BigquervQueryJobOp and the BigqueryPredictModelJobOp components.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Option C is the most efficient way to productionize the model and automatically upload predictions to a BigQuery table on a weekly schedule.\n- DataflowPythonJobOp can be used to preprocess the data and ModelBatchPredictOp can be used to generate predictions.\n- Vertex AI Pipelines can be used to orchestrate the pipeline and schedule it to run on a weekly basis.\n- Option A is not recommended because it requires creating a custom Dataflow pipeline that reuses the data processing logic, which can be complex and error-prone.\n- Option B is not recommended because it requires implementing the data processing logic in a SQL query, which can be inefficient and difficult to maintain.\n- Option D is not recommended because it requires importing the model into BigQuery, which is not necessary and can add unnecessary complexity to the pipeline."
    },
    {
        "Question": "You developed a Vertex AI ML pipeline that consists of preprocessing and training steps and each set of steps runs on a separate custom Dockerimage. Your organization uses GitHub and GitHub Actions as CI/CD to run unit and integration tests. You need to automate the model retrainingworkflow so that it can be initiated both manually and when a new version of the code is merged in the main branch. You want to minimize thesteps required to build the workflow while also allowing for maximum flexibility. How should you configure the CI/CD workflow?",
        "Possible answers": "A)Trigger a Cloud Build workflow to run tests, build custom Docker images, push the images to Artifact Registry, and launch the pipeline inVertex AI Pipelines.\nB)Trigger GitHub Actions to run the tests, launch a job on Cloud Run to build custom Docker images, push the images to Artifact Registry, andlaunch the pipeline in Vertex AI Pipelines.\nC)Trigger GitHub Actions to run the tests, build custom Docker images, push the images to Artifact Registry, and launch the pipeline in VertexAI Pipelines.\nD)Trigger GitHub Actions to run the tests, launch a Cloud Build workflow to build custom Docker images, push the images to Artifact Registry,and launch the pipeline in Vertex AI Pipelines.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Cloud Build is Google's native CI/CD tool\n- Cloud Build can trigger Vertex AI pipelines\n- Cloud Build can build Docker images and push to Artifact Registry"
    },
    {
        "Question": "You have created a Vertex AI pipeline that includes two steps. The first step preprocesses 10 TB data completes in about 1 hour, and saves the result in a Cloud Storage bucket. The second step uses the processed data to train a model. You need to update the model’s code to allow you to test different algorithms. You want to reduce pipeline execution time and cost while also minimizing pipeline changes. What should you do?",
        "Possible answers": "A)Add a pipeline parameter and an additional pipeline step. Depending on the parameter value, the pipeline step conducts or skips data preprocessing, and starts model training.\nB)Create another pipeline without the preprocessing step, and hardcode the preprocessed Cloud Storage file location for model training.\nC)Configure a machine with more CPU and RAM from the compute-optimized machine family for the data preprocessing step.\nD)Enable caching for the pipeline job, and disable caching for the model training step.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Caching can be used to reduce the execution time of the pipeline by reusing the preprocessed data.\n- Disabling caching for the model training step ensures that the model is trained on the latest preprocessed data.\n- Adding a pipeline parameter and an additional pipeline step would increase the complexity of the pipeline and require more changes to the code.\n- Creating another pipeline without the preprocessing step would require significant changes to the code and would not guarantee that the preprocessed data is up-to-date.\n- Configuring a machine with more CPU and RAM would not necessarily reduce the execution time of the pipeline, as the preprocessing step is I/O-bound rather than compute-bound."
    },
    {
        "Question": "You have built a model that is trained on data stored in Parquet files. You access the data through a Hive table hosted on Google Cloud. You preprocessed these data with PySpark and exported it as a CSV file into Cloud Storage. After preprocessing, you execute additional steps to train and evaluate your model. You want to parametrize this model training in Kubeflow Pipelines. What should you do?",
        "Possible answers": "A)Remove the data transformation step from your pipeline.\nB)Containerize the PySpark transformation step, and add it to your pipeline.\nC)Add a ContainerOp to your pipeline that spins a Dataproc cluster, runs a transformation, and then saves the transformed data in Cloud Storage.\nD)Deploy Apache Spark at a separate node pool in a Google Kubernetes Engine cluster. Add a ContainerOp to your pipeline that invokes a corresponding transformation job for this Spark instance.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Option C is the best because it allows you to run your PySpark transformation step in a managed environment without having to worry about setting up and managing your own Spark cluster.\n- Option A is not a good choice because it would remove an important step from your pipeline.\n- Option B is not a good choice because it would require you to containerize your PySpark transformation step, which can be complex and time-consuming.\n- Option D is not a good choice because it would require you to set up and manage your own Spark cluster, which can be complex and time-consuming."
    },
    {
        "Question": "You are the Director of Data Science at a large company, and your Data Science team has recently begun using the Kubeflow Pipelines SDK to orchestrate their training pipelines. Your team is struggling to integrate their custom Python code into the Kubeflow Pipelines SDK. How should you instruct them to proceed in order to quickly integrate their code with the Kubeflow Pipelines SDK?",
        "Possible answers": "A)Use the func_to_container_op function to create custom components from the Python code.\nB)Use the predefined components available in the Kubeflow Pipelines SDK to access Dataproc, and run the custom code there.\nC)Package the custom Python code into Docker containers, and use the load_component_from_file function to import the containers into the pipeline.\nD)Deploy the custom Python code to Cloud Functions, and use Kubeflow Pipelines to trigger the Cloud Function,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n The func_to_container_op function is the best way to integrate custom Python code into the Kubeflow Pipelines SDK. This function allows users to convert a Python function into a containerized component that can be used in a Kubeflow pipeline. This is the most direct and efficient way to integrate custom code with the Kubeflow Pipelines SDK, as it does not require any additional packaging or deployment steps.\n\nOption B is not the best choice because it requires using Dataproc, which may not be necessary or appropriate for the task at hand. Option C is not the best choice because it requires packaging the custom code into Docker containers, which can be a time-consuming and complex process. Option D is not the best choice because it requires deploying the custom code to Cloud Functions, which may not be necessary or appropriate for the task at hand."
    },
    {
        "Question": "You are creating an ML pipeline for data processing, model training, and model deployment that uses different Google Cloud services. You have developed code for each individual task, and you expect a high frequency of new files. You now need to create an orchestration layer on top of these tasks. You only want this orchestration pipeline to run if new files are present in your dataset in a Cloud Storage bucket. You also want to minimize the compute node costs. What should you do?",
        "Possible answers": "A)Create a pipeline in Vertex AI Pipelines. Configure the first step to compare the contents of the bucket to the last time the pipeline was run. Use the scheduler API to run the pipeline periodically.\nB)Create a Cloud Function that uses a Cloud Storage trigger and deploys a Cloud Composer directed acyclic graph (DAG).\nC)Create a pipeline in Vertex AI Pipelines. Create a Cloud Function that uses a Cloud Storage trigger and deploys the pipeline.\nD)Deploy a Cloud Composer directed acyclic graph (DAG) with a GCSObjectUpdateSensor class that detects when a new file is added to the Cloud Storage bucket.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Vertex AI Pipelines can be triggered by Cloud Functions\n- Cloud Functions can be triggered by Cloud Storage events\n- This is the most cost-effective solution because you only pay for the compute time when the pipeline is running"
    },
    {
        "Question": "You have developed an application that uses a chain of multiple scikit-learn models to predict the optimal price for your company’s products. Members of your team use the individual models in other solution workflows. You want to deploy this workflow while ensuring version control for each individual model and the overall workflow. Your application needs to be able to scale down to zero. You want to minimize the compute resource utilization and the manual effort required to manage this solution. What should you do?",
        "Possible answers": "A)Expose each individual model as an endpoint in Vertex AI Endpoints. Create a custom container endpoint to orchestrate the workflow.\nB)Create a custom container endpoint for the workflow that loads each model’s individual files Track the versions of each individual model in BigQuery.\nC)Expose each individual model as an endpoint in Vertex AI Endpoints. Use Cloud Run to orchestrate the workflow.\nD)Load each model’s individual files into Cloud Run. Use Cloud Run to orchestrate the workflow. Track the versions of each individual model in BigQuery.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Cloud Run is a serverless platform that allows you to run your code without having to manage infrastructure.\n- Cloud Run can scale down to zero, which means that you only pay for the resources that you use.\n- Cloud Run supports custom containers, which allows you to deploy your own code.\n- BigQuery can be used to track the versions of each individual model."
    },
    {
        "Question": "Your team frequently creates new ML models and runs experiments. Your team pushes code to a single repository hosted on Cloud Source Repositories. You want to create a continuous integration pipeline that automatically retrains the models whenever there is any modification of the code. What should be your first step to set up the CI pipeline?",
        "Possible answers": "A)Configure a Cloud Build trigger with the event set as \"Pull Request\"\nB)Configure a Cloud Build trigger with the event set as \"Push to a branch\"\nC)Configure a Cloud Function that builds the repository each time there is a code change\nD)Configure a Cloud Function that builds the repository each time a new branch is created,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B is the best choice because it will trigger the CI pipeline every time there is a push to a branch, which is the most common scenario when developers are working on new models or experiments.\n- Option A is not the best choice because it will only trigger the CI pipeline when a pull request is created, which may not always happen if developers are working on a branch locally before creating a pull request.\n- Option C is not the best choice because it will trigger the CI pipeline every time there is a code change, which could be too frequent and may not be necessary for every change.\n- Option D is not the best choice because it will only trigger the CI pipeline when a new branch is created, which is not as common as pushing changes to an existing branch."
    },
    {
        "Question": "You have been tasked with deploying prototype code to production. The feature engineering code is in PySpark and runs on Dataproc Serverless. The model training is executed by using a Vertex AI custom training job. The two steps are not connected, and the model training must currently be run manually after the feature engineering step finishes. You need to create a scalable and maintainable production process that runs end-to-end and tracks the connections between steps. What should you do?",
        "Possible answers": "A)Create a Vertex AI Workbench notebook. Use the notebook to submit the Dataproc Serverless feature engineering job. Use the same notebook to submit the custom model training job. Run the notebook cells sequentially to tie the steps together end-to-end.\nB)Create a Vertex AI Workbench notebook. Initiate an Apache Spark context in the notebook and run the PySpark feature engineering code. Use the same notebook to run the custom model training job in TensorFlow. Run the notebook cells sequentially to tie the steps together end-to-end.\nC)Use the Kubeflow pipelines SDK to write code that specifies two components:- The first is a Dataproc Serverless component that launches the feature engineering job- The second is a custom component wrapped in the create_custom_training_job_from_component utility that launches the custom model training jobCreate a Vertex AI Pipelines job to link and run both components\nD)Use the Kubeflow pipelines SDK to write code that specifies two components- The first component initiates an Apache Spark context that runs the PySpark feature engineering code- The second component runs the TensorFlow custom model training codeCreate a Vertex AI Pipelines job to link and run both components.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Option C uses the Kubeflow Pipelines SDK to write code that specifies two components, which is the recommended way to create a scalable and maintainable production process.\n- The first component is a Dataproc Serverless component that launches the feature engineering job, which is the first step in the process.\n- The second component is a custom component wrapped in the create_custom_training_job_from_component utility that launches the custom model training job, which is the second step in the process.\n- Creating a Vertex AI Pipelines job to link and run both components ensures that the steps are tied together end-to-end and that the model training is run automatically after the feature engineering step finishes.\n\nOption A is not the best choice because it uses a Vertex AI Workbench notebook to submit the Dataproc Serverless feature engineering job and the custom model training job, but it does not use the Kubeflow Pipelines SDK to link and run both components. This means that the steps are not tied together end-to-end and that the model training is not run automatically after the feature engineering step finishes.\n\nOption B is not the best choice because it uses a Vertex AI Workbench notebook to initiate an Apache Spark context and run the PySpark feature engineering code, and then uses the same notebook to run the custom model training job in TensorFlow. This means that the steps are tied together end-to-end, but it is not scalable and maintainable because it is not using the Kubeflow Pipelines SDK.\n\nOption D is not the best choice because it uses the Kubeflow Pipelines SDK to write code that specifies two components, but the first component initiates an Apache Spark context that runs the PySpark feature engineering code, and the second component runs the TensorFlow custom model training code. This means that the steps are tied together end-to-end, but it is not the recommended way to create a scalable and maintainable production process because it is not using the Dataproc Serverless component for the feature engineering step."
    },
    {
        "Question": "You are creating a model training pipeline to predict sentiment scores from text-based product reviews. You want to have control over how the model parameters are tuned, and you will deploy the model to an endpoint after it has been trained. You will use Vertex AI Pipelines to run the pipeline. You need to decide which Google Cloud pipeline components to use. What components should you choose?",
        "Possible answers": "A)TabularDatasetCreateOp, CustomTrainingJobOp, and EndpointCreateOp\nB)TextDatasetCreateOp, AutoMLTextTrainingOp, and EndpointCreateOp\nC)TabularDatasetCreateOp. AutoMLTextTrainingOp, and ModelDeployOp\nD)TextDatasetCreateOp, CustomTrainingJobOp, and ModelDeployOp,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- TextDatasetCreateOp is used to ingest text data\n- CustomTrainingJobOp is used to train a custom model\n- ModelDeployOp is used to deploy the model to an endpoint\n\nAutoMLTextTrainingOp is a managed service that trains a model for you, so you don't have control over the model parameters.\nTabularDatasetCreateOp is used to ingest tabular data, which is not the type of data you are using.\nEndpointCreateOp is used to create an endpoint, but it is not necessary to use this component if you are using ModelDeployOp."
    },
    {
        "Question": "You recently created a new Google Cloud project. After testing that you can submit a Vertex AI Pipeline job from the Cloud Shell, you want to use a Vertex AI Workbench user-managed notebook instance to run your code from that instance. You created the instance and ran the code but this time the job fails with an insufficient permissions error. What should you do?",
        "Possible answers": "A)Ensure that the Workbench instance that you created is in the same region of the Vertex AI Pipelines resources you will use.\nB)Ensure that the Vertex AI Workbench instance is on the same subnetwork of the Vertex AI Pipeline resources that you will use.\nC)Ensure that the Vertex AI Workbench instance is assigned the Identity and Access Management (IAM) Vertex AI User role.\nD)Ensure that the Vertex AI Workbench instance is assigned the Identity and Access Management (IAM) Notebooks Runner role.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The Vertex AI User role is required to access Vertex AI resources, including Pipelines. Without this role, the Workbench instance will not have the necessary permissions to submit a Pipeline job.\n\nOption A is incorrect because the Workbench instance and the Pipelines resources do not need to be in the same region.\n\nOption B is incorrect because the Workbench instance and the Pipelines resources do not need to be on the same subnetwork.\n\nOption D is incorrect because the Notebooks Runner role is not required to submit a Pipeline job."
    },
    {
        "Question": "You recently deployed a pipeline in Vertex AI Pipelines that trains and pushes a model to a Vertex AI endpoint to serve real-time traffic. You need to continue experimenting and iterating on your pipeline to improve model performance. You plan to use Cloud Build for CI/CD You want to quickly and easily deploy new pipelines into production, and you want to minimize the chance that the new pipeline implementations will break in production. What should you do?",
        "Possible answers": "A)Set up a CI/CD pipeline that builds and tests your source code. If the tests are successful, use the Google. Cloud console to upload the built container to Artifact Registry and upload the compiled pipeline to Vertex AI Pipelines.\nB)Set up a CI/CD pipeline that builds your source code and then deploys built artifacts into a pre-production environment. Run unit tests in the pre-production environment. If the tests are successful deploy the pipeline to production.\nC)Set up a CI/CD pipeline that builds and tests your source code and then deploys built artifacts into a pre-production environment. After a successful pipeline run in the pre-production environment, deploy the pipeline to production.\nD)Set up a CI/CD pipeline that builds and tests your source code and then deploys built artifacts into a pre-production environment. After a successful pipeline run in the pre-production environment, rebuild the source code and deploy the artifacts to production.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Option C is the best because it ensures that the pipeline is tested and validated in a pre-production environment before being deployed to production, minimizing the risk of breaking changes.\n- Option A is not as good because it does not involve testing the pipeline in a pre-production environment.\n- Option B is not as good because it does not involve rebuilding the source code after a successful pipeline run in the pre-production environment, which could lead to inconsistencies between the code in the pre-production and production environments.\n- Option D is not as good because it involves rebuilding the source code after a successful pipeline run in the pre-production environment, which is unnecessary and could introduce additional delays in the deployment process."
    },
    {
        "Question": "You are building a TensorFlow text-to-image generative model by using a dataset that contains billions of images with their respective captions. You want to create a low maintenance, automated workflow that reads the data from a Cloud Storage bucket collects statistics, splits the dataset into training/validation/test datasets performs data transformations trains the model using the training/validation datasets, and validates the model by using the test dataset. What should you do?",
        "Possible answers": "A)Use the Apache Airflow SDK to create multiple operators that use Dataflow and Vertex AI services. Deploy the workflow on Cloud Composer.\nB)Use the MLFlow SDK and deploy it on a Google Kubernetes Engine cluster. Create multiple components that use Dataflow and Vertex AI services.\nC)Use the Kubeflow Pipelines (KFP) SDK to create multiple components that use Dataflow and Vertex AI services. Deploy the workflow on Vertex AI Pipelines.\nD)Use the TensorFlow Extended (TFX) SDK to create multiple components that use Dataflow and Vertex AI services. Deploy the workflow on Vertex AI Pipelines.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- TFX is a library for building, managing, and deploying TensorFlow ML pipelines.\n- TFX has components for data ingestion, preprocessing, model training, evaluation, and deployment.\n- TFX can be deployed on Vertex AI Pipelines, which is a fully managed service for building and deploying ML pipelines.\n- TFX is the best choice for this task because it provides a comprehensive set of components for building ML pipelines, and it can be deployed on Vertex AI Pipelines, which is a fully managed service."
    },
    {
        "Question": "You are building a MLOps platform to automate your company’s ML experiments and model retraining. You need to organize the artifacts for dozens of pipelines. How should you store the pipelines’ artifacts?",
        "Possible answers": "A)Store parameters in Cloud SQL, and store the models’ source code and binaries in GitHub.\nB)Store parameters in Cloud SQL, store the models’ source code in GitHub, and store the models’ binaries in Cloud Storage.\nC)Store parameters in Vertex ML Metadata, store the models’ source code in GitHub, and store the models’ binaries in Cloud Storage.\nD)Store parameters in Vertex ML Metadata and store the models’ source code and binaries in GitHub.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Vertex ML Metadata is a centralized store for ML metadata, including model parameters, metrics, and lineage.\n- GitHub is a popular source code management tool that can be used to store the models’ source code.\n- Cloud Storage is a scalable and durable object storage service that can be used to store the models’ binaries.\n\nStoring the parameters in Vertex ML Metadata allows for easy access and management of the model parameters. Storing the models’ source code in GitHub allows for version control and collaboration. Storing the models’ binaries in Cloud Storage provides scalability and durability."
    },
    {
        "Question": "You are developing an ML pipeline using Vertex AI Pipelines. You want your pipeline to upload a new version of the XGBoost model to Vertex AI Model Registry and deploy it to Vertex AI Endpoints for online inference. You want to use the simplest approach. What should you do?",
        "Possible answers": "A)Use the Vertex AI REST API within a custom component based on a vertex-ai/prediction/xgboost-cpu image\nB)Use the Vertex AI ModelEvaluationOp component to evaluate the model\nC)Use the Vertex AI SDK for Python within a custom component based on a python:3.10 image\nD)Chain the Vertex AI ModelUploadOp and ModelDeployOp components together,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The simplest approach to upload a new version of the XGBoost model to Vertex AI Model Registry and deploy it to Vertex AI Endpoints for online inference is to chain the Vertex AI ModelUploadOp and ModelDeployOp components together.\n\nThe ModelUploadOp component uploads a model to Vertex AI Model Registry, and the ModelDeployOp component deploys a model from Vertex AI Model Registry to Vertex AI Endpoints. By chaining these two components together, you can automate the process of uploading and deploying a model with a single pipeline.\n\nThe other options are more complex and require additional steps. For example, using the Vertex AI REST API within a custom component requires you to write custom code to interact with the API. Using the Vertex AI ModelEvaluationOp component to evaluate the model requires you to create a separate pipeline for model evaluation. And using the Vertex AI SDK for Python within a custom component requires you to install the SDK and write custom code to use it.\n\nTherefore, the best answer is to chain the Vertex AI ModelUploadOp and ModelDeployOp components together."
    },
    {
        "Question": "You are analyzing customer data for a healthcare organization that is stored in Cloud Storage. The data contains personally identifiable information (PII). You need to perform data exploration and preprocessing while ensuring the security and privacy of sensitive fields. What should you do?",
        "Possible answers": "A)Use the Cloud Data Loss Prevention (DLP) API to de-identify the PII before performing data exploration and preprocessing.\nB)Use customer-managed encryption keys (CMEK) to encrypt the PII data at rest, and decrypt the PII data during data exploration and preprocessing.\nC)Use a VM inside a VPC Service Controls security perimeter to perform data exploration and preprocessing.\nD)Use Google-managed encryption keys to encrypt the PII data at rest, and decrypt the PII data during data exploration and preprocessing.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n The best answer is A) Use the Cloud Data Loss Prevention (DLP) API to de-identify the PII before performing data exploration and preprocessing.\n\nExplanation:\nThe Cloud Data Loss Prevention (DLP) API is a cloud service that allows you to inspect and de-identify sensitive data in your cloud storage. By using the DLP API, you can protect the privacy of your customers' PII while still allowing you to perform data exploration and preprocessing.\n\nThe other options are not as secure as using the DLP API. Option B) uses customer-managed encryption keys (CMEK) to encrypt the PII data at rest, but this does not protect the data from being decrypted during data exploration and preprocessing. Option C) uses a VM inside a VPC Service Controls security perimeter to perform data exploration and preprocessing, but this is not as secure as using the DLP API because the data is still accessible to the VM. Option D) uses Google-managed encryption keys to encrypt the PII data at rest, but this does not protect the data from being decrypted during data exploration and preprocessing."
    },
    {
        "Question": "You are an ML engineer at a retail company. You have built a model that predicts a coupon to offer an ecommerce customer at checkout based on the items in their cart. When a customer goes to checkout, your serving pipeline, which is hosted on Google Cloud, joins the customer's existing cart with a row in a BigQuery table that contains the customers' historic purchase behavior and uses that as the model's input. The web team is reporting that your model is returning predictions too slowly to load the coupon offer with the rest of the web page. How should you speed up your model's predictions?",
        "Possible answers": "A)Attach an NVIDIA P100 GPU to your deployed model’s instance.\nB)Use a low latency database for the customers’ historic purchase behavior.\nC)Deploy your model to more instances behind a load balancer to distribute traffic.\nD)Create a materialized view in BigQuery with the necessary data for predictions.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best way to speed up the model's predictions is to create a materialized view in BigQuery with the necessary data for predictions. This will reduce the latency of querying the historic purchase behavior data, which is the bottleneck in the current pipeline.\n\nOption A is not the best solution because it would only speed up the predictions for a single instance, but the web team is reporting that the model is returning predictions too slowly in general.\n\nOption B is not the best solution because it would not necessarily reduce the latency of querying the historic purchase behavior data.\n\nOption C is not the best solution because it would only distribute the traffic across multiple instances, but it would not reduce the latency of querying the historic purchase behavior data."
    },
    {
        "Question": "You work for a telecommunications company. You’re building a model to predict which customers may fail to pay their next phone bill. The purpose of this model is to proactively offer at-risk customers assistance such as service discounts and bill deadline extensions. The data is stored in BigQuery and the predictive features that are available for model training include:- Customer ID- Age- Salary- Sex- Average bill value- Number of phone calls in last month- Average duration of phone calls in last monthYou need to investigate and mitigate potential bias against disadvantaged groups, while preserving model accuracy. What should you do?",
        "Possible answers": "A)Determine whether there is a meaningful correlation between the sensitive features and the other features. Train a BigQuery ML boosted trees classification model and exclude the sensitive features and any meaningfully correlated features.\nB)Train a BigQuery ML boosted trees classification model with all features. Use the ML.GLOBAL_EXPLAIN method to calculate the global attribution values for each feature of the model. If the feature importance value for any of the sensitive features exceeds a threshold, discard the model and train without this feature.\nC)Train a BigQuery ML boosted trees classification model with all features. Use the ML.EXPLAIN_PREDICT method to calculate the attribution values for each feature for each customer in a test set. If for any individual customer, the importance value for any feature exceeds a predefined threshold, discard the model and train the model again without this feature.\nD)Define a fairness metric that is represented by accuracy across the sensitive features. Train a BigQuery ML boosted trees classification model with all features. Use the trained model to make predictions on a test set. Join the data back with the sensitive features, and calculate a fairness metric to investigate whether it meets your requirements.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Option D is the best approach because it allows you to evaluate the fairness of the model by calculating a fairness metric that represents accuracy across the sensitive features. This approach enables you to assess whether the model meets your fairness requirements and make necessary adjustments to mitigate bias while preserving model accuracy.\n\n- Option A is not the best approach because it involves excluding sensitive features and any meaningfully correlated features, which may result in the loss of important information that could contribute to the model's accuracy.\n\n- Option B is not the best approach because it relies on global attribution values, which provide an overall view of feature importance but may not capture the impact of sensitive features on individual predictions.\n\n- Option C is not the best approach because it involves discarding the model if the importance value for any feature exceeds a predefined threshold for any individual customer, which may lead to the exclusion of important features and reduced model accuracy."
    },
    {
        "Question": "You work for an online grocery store. You recently developed a custom ML model that recommends a recipe when a user arrives at the website. You chose the machine type on the Vertex AI endpoint to optimize costs by using the queries per second (QPS) that the model can serve, and you deployed it on a single machine with 8 vCPUs and no accelerators. A holiday season is approaching and you anticipate four times more traffic during this time than the typical daily traffic. You need to ensure that the model can scale efficiently to the increased demand. What should you do?",
        "Possible answers": "A)1. Maintain the same machine type on the endpoint. 2. Set up a monitoring job and an alert for CPU usage. 3. If you receive an alert, add a compute node to the endpoint.\nB)1. Change the machine type on the endpoint to have 32 vCPUs. 2. Set up a monitoring job and an alert for CPU usage. 3. If you receive an alert, scale the vCPUs further as needed.\nC)1. Maintain the same machine type on the endpoint Configure the endpoint to enable autoscaling based on vCPU usage. 2. Set up a monitoring job and an alert for CPU usage. 3. If you receive an alert, investigate the cause.\nD)1. Change the machine type on the endpoint to have a GPU. Configure the endpoint to enable autoscaling based on the GPU usage. 2. Set up a monitoring job and an alert for GPU usage. 3. If you receive an alert, investigate the cause.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Autoscaling based on vCPU usage is the best way to handle increased traffic without overprovisioning resources.\n- Option A does not enable autoscaling and relies on manual intervention, which may not be feasible during a high-traffic period.\n- Option B involves changing the machine type, which may not be necessary if autoscaling can handle the increased demand.\n- Option D involves using a GPU, which may not be required for a recommendation system and may increase costs unnecessarily."
    },
    {
        "Question": "You have recently trained a scikit-learn model that you plan to deploy on Vertex AI. This model will support both online and batch prediction. You need to preprocess input data for model inference. You want to package the model for deployment while minimizing additional code. What should you do?",
        "Possible answers": "A)1. Upload your model to the Vertex AI Model Registry by using a prebuilt scikit-ieam prediction container.\t2. Deploy your model to Vertex AI Endpoints, and create a Vertex AI batch prediction job that uses the instanceConfig.instanceType setting to transform your input data.\nB)1. Wrap your model in a custom prediction routine (CPR). and build a container image from the CPR local model. 2. Upload your scikit learn model container to Vertex AI Model Registry. 3. Deploy your model to Vertex AI Endpoints, and create a Vertex AI batch prediction job\nC)1. Create a custom container for your scikit learn model. 2. Define a custom serving function for your model. 3. Upload your model and custom container to Vertex AI Model Registry. 4. Deploy your model to Vertex AI Endpoints, and create a Vertex AI batch prediction job\nD)1. Create a custom container for your scikit learn model. 2. Upload your model and custom container to Vertex AI Model Registry.\t3. Deploy your model to Vertex AI Endpoints, and create a Vertex AI batch prediction job that uses the instanceConfig.instanceType setting to transform your input data.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Prebuilt scikit-learn prediction container doesn't support batch prediction\n- Custom serving function allows for preprocessing\n- Custom container allows for custom serving function"
    },
    {
        "Question": "You are using Vertex AI and TensorFlow to develop a custom image classification model. You need the model’s decisions and the rationale to be understandable to your company’s stakeholders. You also want to explore the results to identify any issues or potential biases. What should you do?",
        "Possible answers": "A)1. Use TensorFlow to generate and visualize features and statistics. 2. Analyze the results together with the standard model evaluation metrics.\nB)1. Use TensorFlow Profiler to visualize the model execution. 2. Analyze the relationship between incorrect predictions and execution bottlenecks.\nC)1. Use Vertex Explainable AI to generate example-based explanations. 2. Visualize the results of sample inputs from the entire dataset together with the standard model evaluation metrics.\nD)1. Use Vertex Explainable AI to generate feature attributions. Aggregate feature attributions over the entire dataset. 2. Analyze the aggregation result together with the standard model evaluation metrics.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Vertex Explainable AI can be used to generate example-based explanations for image classification models.\n- Visualizing the results of sample inputs from the entire dataset together with the standard model evaluation metrics allows you to understand the model's performance and identify any issues or potential biases.\n\nOther options:\n- Option A: TensorFlow can be used to generate and visualize features and statistics, but it does not provide example-based explanations or the ability to visualize the results of sample inputs from the entire dataset.\n- Option B: TensorFlow Profiler can be used to visualize the model execution, but it does not provide example-based explanations or the ability to visualize the results of sample inputs from the entire dataset.\n- Option D: Vertex Explainable AI can be used to generate feature attributions, but aggregating feature attributions over the entire dataset may not provide meaningful insights."
    },
    {
        "Question": "You are deploying a new version of a model to a production Vertex Al endpoint that is serving traffic. You plan to direct all user traffic to the new model. You need to deploy the model with minimal disruption to your application. What should you do?",
        "Possible answers": "A)1. Create a new endpoint2. Create a new model. Set it as the default version. Upload the model to Vertex AI Model Registry3. Deploy the new model to the new endpoint4. Update Cloud DNS to point to the new endpoint\nB)1. Create a new endpoint2. Create a new model. Set the parentModel parameter to the model ID of the currently deployed model and set it as the default version. Upload the model to Vertex AI Model Registry3. Deploy the new model to the new endpoint, and set the new model to 100% of the traffic.\nC)1. Create a new model. Set the parentModel parameter to the model ID of the currently deployed model. Upload the model to Vertex AI Model Registry. 2. Deploy the new model to the existing endpoint, and set the new model to 100% of the traffic\nD)1. Create a new model. Set it as the default version. Upload the model to Vertex AI Model Registry2. Deploy the new model to the existing endpoint,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Creating a new endpoint would cause downtime\n- Setting the new model to 100% of the traffic immediately would cause downtime\n- Option C allows for a gradual rollout of the new model with no downtime"
    },
    {
        "Question": "You recently used XGBoost to train a model in Python that will be used for online serving. Your model prediction service will be called by a backend service implemented in Golang running on a Google Kubernetes Engine (GKE) cluster. Your model requires pre and postprocessing steps. You need to implement the processing steps so that they run at serving time. You want to minimize code changes and infrastructure maintenance, and deploy your model into production as quickly as possible. What should you do?",
        "Possible answers": "A)Use FastAPI to implement an HTTP server. Create a Docker image that runs your HTTP server, and deploy it on your organization’s GKE cluster.\nB)Use FastAPI to implement an HTTP server. Create a Docker image that runs your HTTP server, Upload the image to Vertex AI Model Registry and deploy it to a Vertex AI endpoint.\nC)Use the Predictor interface to implement a custom prediction routine. Build the custom container, upload the container to Vertex AI Model Registry and deploy it to a Vertex AI endpoint.\nD)Use the XGBoost prebuilt serving container when importing the trained model into Vertex AI. Deploy the model to a Vertex AI endpoint. Work with the backend engineers to implement the pre- and postprocessing steps in the Golang backend service.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best answer is C) Use the Predictor interface to implement a custom prediction routine. Build the custom container, upload the container to Vertex AI Model Registry and deploy it to a Vertex AI endpoint.\n\nHere's why:\n\n- The Predictor interface allows you to implement custom pre- and post-processing steps for your model. This gives you more control over the prediction process and ensures that your model is used correctly.\n- Building a custom container allows you to package your model and its dependencies together, making it easier to deploy and manage.\n- Uploading the container to Vertex AI Model Registry makes it easy to version and manage your models.\n- Deploying the model to a Vertex AI endpoint provides a scalable and reliable way to serve your model to clients.\n\nHere's why the other options are not as good:\n\n- Option A) requires you to implement an HTTP server and deploy it on your organization's GKE cluster. This adds complexity and maintenance overhead to your deployment.\n- Option B) requires you to upload your Docker image to Vertex AI Model Registry, which can be time-consuming and may require additional configuration.\n- Option D) does not allow you to implement custom pre- and post-processing steps for your model."
    },
    {
        "Question": "You recently deployed a model to a Vertex AI endpoint. Your data drifts frequently, so you have enabled request-response logging and created a Vertex AI Model Monitoring job. You have observed that your model is receiving higher traffic than expected. You need to reduce the model monitoring cost while continuing to quickly detect drift. What should you do?",
        "Possible answers": "A)Replace the monitoring job with a DataFlow pipeline that uses TensorFlow Data Validation (TFDV)\nB)Replace the monitoring job with a custom SQL script to calculate statistics on the features and predictions in BigQuery\nC)Decrease the sample_rate parameter in the RandomSampleConfig of the monitoring job\nD)Increase the monitor_interval parameter in the ScheduleConfig of the monitoring job,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best answer is C) Decrease the sample_rate parameter in the RandomSampleConfig of the monitoring job.\n\nThe model is receiving higher traffic than expected, so reducing the sample rate will reduce the number of requests that are sent to the monitoring job, which will in turn reduce the cost of monitoring. However, it is important to note that reducing the sample rate will also reduce the amount of data that is available for monitoring, so it is important to find a balance between cost and data availability.\n\nAnswer B is incorrect because a custom SQL script would not be able to provide the same level of monitoring as a Vertex AI Model Monitoring job.\n\nAnswer D is incorrect because increasing the monitor_interval parameter would increase the time between monitoring checks, which would make it more likely that drift would go undetected."
    },
    {
        "Question": "You received a training-serving skew alert from a Vertex AI Model Monitoring job running in production. You retrained the model with more recenttraining data, and deployed it back to the Vertex AI endpoint, but you are still receiving the same alert. What should you do?",
        "Possible answers": "A)Update the model monitoring job to use a lower sampling rate.\nB)Update the model monitoring job to use the more recent training data that was used to retrain the model.\nC)Temporarily disable the alert. Enable the alert again after a sufficient amount of new production traffic has passed through the Vertex AIendpoint.\nD)Temporarily disable the alert until the model can be retrained again on newer training data. Retrain the model again after a sufficientamount of new production traffic has passed through the Vertex AI endpoint.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The training-serving skew alert indicates that the model predictions on production data are significantly different from the predictions on the training data. This could be due to several reasons, including changes in the production data distribution, model drift, or issues with the model training process.\n\nUpdating the model monitoring job to use the more recent training data that was used to retrain the model is the best solution because it allows the model monitoring job to compare the model predictions on production data with the predictions on the training data that was used to train the model. This will help identify if the model drift is due to changes in the production data distribution or issues with the model training process.\n\nUpdating the model monitoring job to use a lower sampling rate or temporarily disabling the alert will not address the root cause of the training-serving skew. Retraining the model again after a sufficient amount of new production traffic has passed through the Vertex AI endpoint may help mitigate the issue, but it does not address the underlying cause of the skew."
    },
    {
        "Question": "You have developed a BigQuery ML model that predicts customer chum, and deployed the model to Vertex AI Endpoints. You want to automate the retraining of your model by using minimal additional code when model feature values change. You also want to minimize the number of times that your model is retrained to reduce training costs. What should you do?",
        "Possible answers": "A)1 Enable request-response logging on Vertex AI Endpoints2. Schedule a TensorFlow Data Validation job to monitor prediction drift3. Execute model retraining if there is significant distance between the distributions\nB)1. Enable request-response logging on Vertex AI Endpoints2. Schedule a TensorFlow Data Validation job to monitor training/serving skew3. Execute model retraining if there is significant distance between the distributions\nC)1. Create a Vertex AI Model Monitoring job configured to monitor prediction drift2. Configure alert monitoring to publish a message to a Pub/Sub queue when a monitoring alert is detected3. Use a Cloud Function to monitor the Pub/Sub queue, and trigger retraining in BigQuery\nD)1. Create a Vertex AI Model Monitoring job configured to monitor training/serving skew2. Configure alert monitoring to publish a message to a Pub/Sub queue when a monitoring alert is detected3. Use a Cloud Function to monitor the Pub/Sub queue, and trigger retraining in BigQuery,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n - Model monitoring is used to monitor prediction drift\n- Pub/Sub is used to trigger retraining"
    },
    {
        "Question": "You work for a small company that has deployed an ML model with autoscaling on Vertex AI to serve online predictions in a production environment. The current model receives about 20 prediction requests per hour with an average response time of one second. You have retrained the same model on a new batch of data, and now you are canary testing it, sending ~10% of production traffic to the new model. During this canary test, you notice that prediction requests for your new model are taking between 30 and 180 seconds to complete. What should you do?",
        "Possible answers": "A)Submit a request to raise your project quota to ensure that multiple prediction services can run concurrently.\nB)Turn off auto-scaling for the online prediction service of your new model. Use manual scaling with one node always available.\nC)Remove your new model from the production environment. Compare the new model and existing model codes to identify the cause of the performance bottleneck.\nD)Remove your new model from the production environment. For a short trial period, send all incoming prediction requests to BigQuery. Request batch predictions from your new model, and then use the Data Labeling Service to validate your model’s performance before promoting it to production.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n The best answer is C) Remove your new model from the production environment. Compare the new model and existing model codes to identify the cause of the performance bottleneck.\n\nHere's why:\n\nA) Submit a request to raise your project quota to ensure that multiple prediction services can run concurrently.\nThis is not the best answer because it does not address the root cause of the performance bottleneck. Even if you increase your project quota, the prediction requests for your new model will still take a long time to complete if there is a performance issue with the model itself.\n\nB) Turn off auto-scaling for the online prediction service of your new model. Use manual scaling with one node always available.\nThis is not the best answer because it will prevent your new model from scaling up to meet demand if the number of prediction requests increases. This could lead to increased latency and decreased throughput for your model.\n\nD) Remove your new model from the production environment. For a short trial period, send all incoming prediction requests to BigQuery. Request batch predictions from your new model, and then use the Data Labeling Service to validate your model’s performance before promoting it to production.\nThis is not the best answer because it will take your new model out of production for a period of time, which could impact your business. Additionally, batch predictions may not be suitable for your use case if you need real-time predictions.\n\nTherefore, the best answer is C) Remove your new model from the production environment. Compare the new model and existing model codes to identify the cause of the performance bottleneck. This will allow you to identify and fix the issue with your new model before promoting it to production."
    },
    {
        "Question": "You have deployed a scikit-team model to a Vertex AI endpoint using a custom model server. You enabled autoscaling: however, the deployed model fails to scale beyond one replica, which led to dropped requests. You notice that CPU utilization remains low even during periods of high load. What should you do?",
        "Possible answers": "A)Attach a GPU to the prediction nodes\nB)Increase the number of workers in your model server\nC)Schedule scaling of the nodes to match expected demand\nD)Increase the minReplicaCount in your DeployedModel configuration,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The correct answer is B: Increase the number of workers in your model server.\n\nThe issue here is that the model is not scaling beyond one replica, even though autoscaling is enabled. This means that the model is not able to handle the incoming requests, which is leading to dropped requests.\n\nIncreasing the number of workers in the model server will allow the model to handle more requests concurrently, which should resolve the issue of dropped requests.\n\nOption A is not correct because attaching a GPU to the prediction nodes will not help if the model is not CPU-bound.\n\nOption C is not correct because scheduling scaling of the nodes will not help if the model is not able to handle the incoming requests even when the nodes are scaled up.\n\nOption D is not correct because increasing the minReplicaCount in the DeployedModel configuration will not help if the model is not able to handle the incoming requests even when the minimum number of replicas is reached."
    },
    {
        "Question": "You work for a bank with strict data governance requirements. You recently implemented a custom model to detect fraudulent transactions. You want your training code to download internal data by using an API endpoint hosted in your project’s network. You need the data to be accessed in the most secure way, while mitigating the risk of data exfiltration. What should you do?",
        "Possible answers": "A)Enable VPC Service Controls for peerings, and add Vertex AI to a service perimeter.\nB)Create a Cloud Run endpoint as a proxy to the data. Use Identity and Access Management (IAM) authentication to secure access to the endpoint from the training job.\nC)Configure VPC Peering with Vertex AI, and specify the network of the training job.\nD)Download the data to a Cloud Storage bucket before calling the training job.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n VPC Service Controls for peerings, and add Vertex AI to a service perimeter.\n\nThis option provides the most secure way to access internal data from a training job, while mitigating the risk of data exfiltration. VPC Service Controls allows you to control access to services within your VPC network, and adding Vertex AI to a service perimeter ensures that only authorized training jobs can access the data."
    },
    {
        "Question": "You work for a large bank that serves customers through an application hosted in Google Cloud that is running in the US and Singapore. You have developed a PyTorch model to classify transactions as potentially fraudulent or not. The model is a three-layer perceptron that uses both numerical and categorical features as input, and hashing happens within the model.You deployed the model to the us-central1 region on nl-highcpu-16 machines, and predictions are served in real time. The model's current median response latency is 40 ms. You want to reduce latency, especially in Singapore, where some customers are experiencing the longest delays. What should you do?",
        "Possible answers": "A)Attach an NVIDIA T4 GPU to the machines being used for online inference.\nB)Change the machines being used for online inference to nl-highcpu-32.\nC)Deploy the model to Vertex AI private endpoints in the us-central1 and asia-southeast1 regions, and allow the application to choose the appropriate endpoint.\nD)Create another Vertex AI endpoint in the asia-southeast1 region, and allow the application to choose the appropriate endpoint.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n - Private endpoints are the best way to reduce latency\n- Private endpoints are only available in Vertex AI"
    },
    {
        "Question": "Your work for a textile manufacturing company. Your company has hundreds of machines, and each machine has many sensors. Your team used the sensory data to build hundreds of ML models that detect machine anomalies. Models are retrained daily, and you need to deploy these models in a cost-effective way. The models must operate 24/7 without downtime and make sub millisecond predictions. What should you do?",
        "Possible answers": "A)Deploy a Dataflow batch pipeline and a Vertex AI Prediction endpoint.\nB)Deploy a Dataflow batch pipeline with the Runlnference API, and use model refresh.\nC)Deploy a Dataflow streaming pipeline and a Vertex AI Prediction endpoint with autoscaling.\nD)Deploy a Dataflow streaming pipeline with the Runlnference API, and use automatic model refresh.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Dataflow streaming pipeline is needed for sub millisecond predictions\n- Autoscaling is needed for 24/7 operation without downtime"
    },
    {
        "Question": "You are using Vertex AI and TensorFlow to develop a custom image classification model. You need the model’s decisions and the rationale to be understandable to your company’s stakeholders. You also want to explore the results to identify any issues or potential biases. What should you do?",
        "Possible answers": "A)1. Use TensorFlow to generate and visualize features and statistics. 2. Analyze the results together with the standard model evaluation metrics.\nB)1. Use TensorFlow Profiler to visualize the model execution. 2. Analyze the relationship between incorrect predictions and execution bottlenecks.\nC)1. Use Vertex Explainable AI to generate example-based explanations. 2. Visualize the results of sample inputs from the entire dataset together with the standard model evaluation metrics.\nD) 1. Use Vertex Explainable AI to generate feature attributions. Aggregate feature attributions over the entire dataset. 2. Analyze the aggregation result together with the standard model evaluation metrics.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D because:\n\n1. Vertex Explainable AI can generate feature attributions, which provide insights into how the model makes predictions. Aggregating feature attributions over the entire dataset can help identify important features and patterns.\n2. Analyzing the aggregated feature attributions together with standard model evaluation metrics provides a comprehensive understanding of the model's performance and potential biases.\n\nOther options:\n\nA) Generating and visualizing features and statistics using TensorFlow provides some insights into the model's behavior, but it does not offer explanations for individual predictions or address potential biases.\n\nB) Using TensorFlow Profiler to visualize the model execution can help identify performance bottlenecks, but it does not provide explanations for the model's decisions or address potential biases.\n\nC) Generating example-based explanations using Vertex Explainable AI can provide insights into individual predictions, but visualizing the results of sample inputs from the entire dataset together with standard model evaluation metrics does not provide a comprehensive analysis of the model's behavior or potential biases."
    },
    {
        "Question": "You have trained a model by using data that was preprocessed in a batch Dataflow pipeline. Your use case requires real-time inference. You want to ensure that the data preprocessing logic is applied consistently between training and serving. What should you do?",
        "Possible answers": "A)Perform data validation to ensure that the input data to the pipeline is the same format as the input data to the endpoint.\nB)Refactor the transformation code in the batch data pipeline so that it can be used outside of the pipeline. Use the same code in the endpoint.\nC)Refactor the transformation code in the batch data pipeline so that it can be used outside of the pipeline. Share this code with the end users of the endpoint.\nD)Batch the real-time requests by using a time window and then use the Dataflow pipeline to preprocess the batched requests. Send the preprocessed requests to the endpoint.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Refactoring the transformation code in the batch data pipeline so that it can be used outside of the pipeline ensures that the same data preprocessing logic is applied consistently between training and serving.\n- This approach allows for a seamless transition from training to serving, ensuring that the model receives preprocessed data in the same format during both training and real-time inference.\n- Options A, C, and D introduce additional complexities and potential inconsistencies in the data preprocessing logic, which can lead to discrepancies between training and serving."
    },
    {
        "Question": "You have developed a BigQuery ML model that predicts customer chum, and deployed the model to Vertex AI Endpoints. You want to automate the retraining of your model by using minimal additional code when model feature values change. You also want to minimize the number of times that your model is retrained to reduce training costs. What should you do?",
        "Possible answers": "A)1 Enable request-response logging on Vertex AI Endpoints2. Schedule a TensorFlow Data Validation job to monitor prediction drift3. Execute model retraining if there is significant distance between the distributions\nB)1. Enable request-response logging on Vertex AI Endpoints2. Schedule a TensorFlow Data Validation job to monitor training/serving skew3. Execute model retraining if there is significant distance between the distributions\nC)1. Create a Vertex AI Model Monitoring job configured to monitor prediction drift2. Configure alert monitoring to publish a message to a Pub/Sub queue when a monitoring alert is detected3. Use a Cloud Function to monitor the Pub/Sub queue, and trigger retraining in BigQuery\nD)1. Create a Vertex AI Model Monitoring job configured to monitor training/serving skew2. Configure alert monitoring to publish a message to a Pub/Sub queue when a monitoring alert is detected3. Use a Cloud Function to monitor the Pub/Sub queue, and trigger retraining in BigQuery,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n - Model monitoring is used to monitor prediction drift\n- Pub/Sub is used to trigger retraining"
    },
    {
        "Question": "You work for a pharmaceutical company based in Canada. Your team developed a BigQuery ML model to predict the number of flu infections for the next month in Canada. Weather data is published weekly, and flu infection statistics are published monthly. You need to configure a model retraining policy that minimizes cost. What should you do?",
        "Possible answers": "A)Download the weather and flu data each week. Configure Cloud Scheduler to execute a Vertex AI pipeline to retrain the model weekly.\nB)Download the weather and flu data each month. Configure Cloud Scheduler to execute a Vertex AI pipeline to retrain the model monthly.\nC)Download the weather and flu data each week. Configure Cloud Scheduler to execute a Vertex AI pipeline to retrain the model every month.\nD)Download the weather data each week, and download the flu data each month. Deploy the model to a Vertex AI endpoint with feature drift monitoring, and retrain the model if a monitoring alert is detected.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Feature drift monitoring is the best way to minimize cost\n- Feature drift monitoring will only retrain the model when needed"
    },
    {
        "Question": "You are developing a model to help your company create more targeted online advertising campaigns. You need to create a dataset that you will use to train the model. You want to avoid creating or reinforcing unfair bias in the model. What should you do? (Choose two.)",
        "Possible answers": "A)Include a comprehensive set of demographic features\nB)Include only the demographic groups that most frequently interact with advertisements\nC)Collect a random sample of production traffic to build the training dataset\nD)Collect a stratified sample of production traffic to build the training dataset\nE)Conduct fairness tests across sensitive categories and demographics on the trained model,",
        "Correct answer & Explanation": "Correct Answer:\nD and E\n\nExplanation:\n"
    },
    {
        "Question": "You work at a mobile gaming startup that creates online multiplayer games. Recently, your company observed an increase in players cheating in the games, leading to a loss of revenue and a poor user experience You built a binary classification model to determine whether a player cheated after a completed game session, and then send a message to other downstream systems to ban the player that cheated. Your model has performed well during testing, and you now need to deploy the model to production. You want your serving solution to provide immediate classifications after a completed game session to avoid further loss of revenue. What should you do?",
        "Possible answers": "A)Import the model into Vertex AI Model Registry. Use the Vertex Batch Prediction service to run batch inference jobs.\nB)Save the model files in a Cloud Storage bucket. Create a Cloud Function to read the model files and make online inference requests on the Cloud Function.\nC)Save the model files in a VM. Load the model files each time there is a prediction request, and run an inference job on the VM\nD)Import the model into Vertex AI Model Registry. Create a Vertex AI endpoint that hosts the model, and make online inference requests,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Batch prediction is not used for real-time inference\n- Cloud functions are not used for real-time inference\n- Loading the model each time is inefficient\n- Option D is the best choice because it allows for real-time inference and is a managed service"
    },
    {
        "Question": "You work for a manufacturing company. You need to train a custom image classification model to detect product defects at the end of an assembly line. Although your model is performing well, some images in your holdout set are consistently mislabeled with high confidence. You want to use Vertex AI to understand your model’s results. What should you do?",
        "Possible answers": "A)Configure feature-based explanations by using Integrated Gradients. Set visualization type to PIXELS, and set clip_percent_upperbound to 95.\nB)Create an index by using Vertex AI Matching Engine. Query the index with your mislabeled images.\nC)Configure feature-based explanations by using XRAI. Set visualization type to OUTLINES, and set polarity to positive.\nD)Configure example-based explanations. Specify the embedding output layer to be used for the latent space representation.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n - Integrated Gradients is a feature-based explanation method that can help you understand why your model is making certain predictions.\n- By setting the visualization type to PIXELS, you can see how each pixel in an image contributes to the model's prediction.\n- By setting the clip_percent_upperbound to 95, you can focus on the most important pixels that are contributing to the model's prediction."
    },
    {
        "Question": "You developed a custom model by using Vertex AI to predict your application's user churn rate. You are using Vertex AI Model Monitoring for skew detection. The training data stored in BigQuery contains two sets of features - demographic and behavioral. You later discover that two separate models trained on each set perform better than the original model. You need to configure a new model monitoring pipeline that splits traffic among the two models. You want to use the same prediction-sampling-rate and monitoring-frequency for each model. You also want to minimize management effort. What should you do?",
        "Possible answers": "A)Keep the training dataset as is. Deploy the models to two separate endpoints, and submit two Vertex AI Model Monitoring jobs with appropriately selected feature-thresholds parameters.\nB)Keep the training dataset as is. Deploy both models to the same endpoint and submit a Vertex AI Model Monitoring job with a monitoring-config-from-file parameter that accounts for the model IDs and feature selections.\nC)Separate the training dataset into two tables based on demographic and behavioral features. Deploy the models to two separate endpoints, and submit two Vertex AI Model Monitoring jobs.\nD)Separate the training dataset into two tables based on demographic and behavioral features. Deploy both models to the same endpoint, and submit a Vertex AI Model Monitoring job with a monitoring-config-from-file parameter that accounts for the model IDs and training datasets.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Option D allows you to use the same prediction-sampling-rate and monitoring-frequency for each model.\n- Option D also minimizes management effort by deploying both models to the same endpoint and using a single Vertex AI Model Monitoring job."
    },
    {
        "Question": "You have built a custom model that performs several memory-intensive preprocessing tasks before it makes a prediction. You deployed the model to a Vertex AI endpoint, and validated that results were received in a reasonable amount of time. After routing user traffic to the endpoint, you discover that the endpoint does not autoscale as expected when receiving multiple requests. What should you do?",
        "Possible answers": "A)Use a machine type with more memory\nB)Decrease the number of workers per machine\nC)Increase the CPU utilization target in the autoscaling configurations.\nD)Decrease the CPU utilization target in the autoscaling configurations,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The correct answer is D) Decrease the CPU utilization target in the autoscaling configurations.\n\nExplanation:\nThe model performs several memory-intensive preprocessing tasks, so the limiting factor is likely to be memory rather than CPU. Decreasing the CPU utilization target will allow the autoscaler to add more instances to the endpoint, which will increase the available memory and allow the endpoint to handle more requests.\n\nHere's why the other options are not the best choices:\n\nA) Use a machine type with more memory: This may help if the bottleneck is indeed memory, but it's not the most cost-effective solution. Decreasing the CPU utilization target is a more targeted approach that will only add instances when needed, saving you money.\n\nB) Decrease the number of workers per machine: This may help reduce memory usage, but it will also reduce the endpoint's throughput. Since the endpoint is not autoscaling as expected, reducing the number of workers will only make the problem worse.\n\nC) Increase the CPU utilization target in the autoscaling configurations: This will not help because the limiting factor is memory, not CPU. Increasing the CPU utilization target will not allow the autoscaler to add more instances to the endpoint."
    },
    {
        "Question": "You recently deployed a scikit-learn model to a Vertex AI endpoint. You are now testing the model on live production traffic. While monitoring the endpoint, you discover twice as many requests per hour than expected throughout the day. You want the endpoint to efficiently scale when the demand increases in the future to prevent users from experiencing high latency. What should you do?",
        "Possible answers": "A)Deploy two models to the same endpoint, and distribute requests among them evenly\nB)Configure an appropriate minReplicaCount value based on expected baseline traffic\nC)Set the target utilization percentage in the autoscailngMetricSpecs configuration to a higher value\nD)Change the model’s machine type to one that utilizes GPUs,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n The best answer is B) Configure an appropriate minReplicaCount value based on expected baseline traffic.\n\nExplanation:\nBy setting an appropriate minReplicaCount value, you can ensure that the endpoint has enough replicas running to handle the expected baseline traffic. This will help prevent the endpoint from becoming overloaded and experiencing high latency when the demand increases.\n\nAnswer A is not the best answer because deploying two models to the same endpoint will not necessarily distribute requests evenly between them. Answer C is not the best answer because setting the target utilization percentage in the autoscalingMetricSpecs configuration to a higher value will not prevent the endpoint from becoming overloaded if the demand increases beyond the target utilization percentage. Answer D is not the best answer because changing the model's machine type to one that utilizes GPUs will not necessarily improve the endpoint's ability to handle increased demand."
    },
    {
        "Question": "You work for a bank. You have created a custom model to predict whether a loan application should be flagged for human review. The input features are stored in a BigQuery table. The model is performing well, and you plan to deploy it to production. Due to compliance requirements the model must provide explanations for each prediction. You want to add this functionality to your model code with minimal effort and provide explanations that are as accurate as possible. What should you do?",
        "Possible answers": "A)Create an AutoML tabular model by using the BigQuery data with integrated Vertex Explainable AI\nB)Create a BigQuery ML deep neural network model and use the ML.EXPLAIN_PREDICT method with the num_integral_steps parameter.\nC)Upload the custom model to Vertex AI Model Registry and configure feature-based attribution by using sampled Shapley with input baselines.\nD)Update the custom serving container to include sampled Shapley-based explanations in the prediction outputs.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- AutoML tabular models do not support Vertex Explainable AI\n- BigQuery ML models do not support feature-based attribution\n- Option D requires custom code and is not as accurate as sampled Shapley"
    },
    {
        "Question": "You recently used BigQuery ML to train an AutoML regression model. You shared results with your team and received positive feedback. You need to deploy your model for online prediction as quickly as possible. What should you do?",
        "Possible answers": "A)Retrain the model by using BigQuery ML, and specify Vertex AI as the model registry. Deploy the model from Vertex AI Model Registry to a Vertex AI endpoint\nB)Retrain the model by using Vertex Al Deploy the model from Vertex AI Model. Registry to a Vertex AI endpoint.\nC)Alter the model by using BigQuery ML, and specify Vertex AI as the model registry. Deploy the model from Vertex AI Model Registry to a Vertex AI endpoint\nD)Export the model from BigQuery ML to Cloud Storage. Import the model into Vertex AI Model Registry. Deploy the model to a Vertex AI endpoint.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- You can't retrain a model in BigQuery ML and specify Vertex AI as the model registry.\n- You can't export a model from BigQuery ML to Cloud Storage.\n- Altering the model by using BigQuery ML, and specifying Vertex AI as the model registry, and then deploying the model from Vertex AI Model Registry to a Vertex AI endpoint is the fastest way to deploy your model for online prediction."
    },
    {
        "Question": "You work at a bank. You have a custom tabular ML model that was provided by the bank’s vendor. The training data is not available due to its sensitivity. The model is packaged as a Vertex AI Model serving container, which accepts a string as input for each prediction instance. In each string, the feature values are separated by commas. You want to deploy this model to production for online predictions and monitor the feature distribution over time with minimal effort. What should you do?",
        "Possible answers": "A)1. Upload the model to Vertex AI Model Registry, and deploy the model to a Vertex AI endpoint2. Create a Vertex AI Model Monitoring job with feature drift detection as the monitoring objective, and provide an instance schema\nB)1. Upload the model to Vertex AI Model Registry, and deploy the model to a Vertex AI endpoint2. Create a Vertex AI Model Monitoring job with feature skew detection as the monitoring objective, and provide an instance schema\nC)1. Refactor the serving container to accept key-value pairs as input format2. Upload the model to Vertex AI Model Registry, and deploy the model to a Vertex AI endpoint3. Create a Vertex AI Model Monitoring job with feature drift detection as the monitoring objective.\nD)1. Refactor the serving container to accept key-value pairs as input format2. Upload the model to Vertex AI Model Registry, and deploy the model to a Vertex AI endpoint3. Create a Vertex AI Model Monitoring job with feature skew detection as the monitoring objective,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Feature drift is the gradual change in the distribution of input features over time.\n- Feature skew is the uneven distribution of input features.\n- Since the training data is not available, we cannot calculate the feature statistics to detect feature skew.\n- Therefore, we should use feature drift detection as the monitoring objective.\n- We can provide an instance schema to help the monitoring job understand the input format."
    },
    {
        "Question": "You are training and deploying updated versions of a regression model with tabular data by using Vertex AI Pipelines, Vertex AI Training, Vertex AI Experiments, and Vertex AI Endpoints. The model is deployed in a Vertex AI endpoint, and your users call the model by using the Vertex AI endpoint. You want to receive an email when the feature data distribution changes significantly, so you can retrigger the training pipeline and deploy an updated version of your model. What should you do?",
        "Possible answers": "A)Use Vertex Al Model Monitoring. Enable prediction drift monitoring on the endpoint, and specify a notification email.\nB)In Cloud Logging, create a logs-based alert using the logs in the Vertex Al endpoint. Configure Cloud Logging to send an email when the alert is triggered.\nC)In Cloud Monitoring create a logs-based metric and a threshold alert for the metric. Configure Cloud Monitoring to send an email when the alert is triggered.\nD)Export the container logs of the endpoint to BigQuery. Create a Cloud Function to run a SQL query over the exported logs and send an email. Use Cloud Scheduler to trigger the Cloud Function.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n Explanation:\n- Vertex AI Model Monitoring is a service that continuously monitors your machine learning models in production.\n- Prediction drift monitoring detects when the distribution of the features in your production data changes significantly from the distribution of the features in your training data.\n- You can specify a notification email to be sent when prediction drift is detected."
    },
    {
        "Question": "Your team has a model deployed to a Vertex AI endpoint. You have created a Vertex AI pipeline that automates the model training process and is triggered by a Cloud Function. You need to prioritize keeping the model up-to-date, but also minimize retraining costs. How should you configure retraining?",
        "Possible answers": "A)Configure Pub/Sub to call the Cloud Function when a sufficient amount of new data becomes available\nB)Configure a Cloud Scheduler job that calls the Cloud Function at a predetermined frequency that fits your team’s budget\nC)Enable model monitoring on the Vertex AI endpoint. Configure Pub/Sub to call the Cloud Function when anomalies are detected\nD)Enable model monitoring on the Vertex AI endpoint. Configure Pub/Sub to call the Cloud Function when feature drift is detected,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The best answer is D) Enable model monitoring on the Vertex AI endpoint. Configure Pub/Sub to call the Cloud Function when feature drift is detected.\n\nHere's why:\n\nFeature drift occurs when the distribution of features in the training data changes over time. This can lead to the model making incorrect predictions. By enabling model monitoring on the Vertex AI endpoint, you can track the performance of the model and detect when feature drift occurs. When feature drift is detected, you can trigger the Cloud Function to retrain the model.\n\nOption A is not the best answer because it does not take into account the cost of retraining the model. Retraining the model can be expensive, so it is important to only retrain the model when necessary.\n\nOption B is not the best answer because it does not take into account the need to keep the model up-to-date. If you retrain the model at a predetermined frequency, you may not be able to keep the model up-to-date with the latest data.\n\nOption C is not the best answer because it does not take into account the need to minimize retraining costs. Retraining the model can be expensive, so it is important to only retrain the model when necessary."
    },
    {
        "Question": "You work for a retail company. You have created a Vertex AI forecast model that produces monthly item sales predictions. You want to quickly create a report that will help to explain how the model calculates the predictions. You have one month of recent actual sales data that was not included in the training dataset. How should you generate data for your report?",
        "Possible answers": "A)Create a batch prediction job by using the actual sales data. Compare the predictions to the actuals in the report.\nB)Create a batch prediction job by using the actual sales data, and configure the job settings to generate feature attributions. Compare the results in the report.\nC)Generate counterfactual examples by using the actual sales data. Create a batch prediction job using the actual sales data and the counterfactual examples. Compare the results in the report.\nD)Train another model by using the same training dataset as the original, and exclude some columns. Using the actual sales data create one batch prediction job by using the new model and another one with the original model. Compare the two sets of predictions in the report.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Feature attributions show how each feature contributes to the prediction\n- Counterfactuals are used to see how the prediction would change if a feature value was different\n- Option D is not needed since we already have the original model"
    },
    {
        "Question": "You built a deep learning-based image classification model by using on-premises data. You want to use Vertex AI to deploy the model to production. Due to security concerns, you cannot move your data to the cloud. You are aware that the input data distribution might change over time. You need to detect model performance changes in production. What should you do?",
        "Possible answers": "A)Use Vertex Explainable AI for model explainability. Configure feature-based explanations.\nB)Use Vertex Explainable AI for model explainability. Configure example-based explanations.\nC)Create a Vertex AI Model Monitoring job. Enable training-serving skew detection for your model.\nD)Create a Vertex AI Model Monitoring job. Enable feature attribution skew and drift detection for your model.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n The correct answer is D: Create a Vertex AI Model Monitoring job. Enable feature attribution skew and drift detection for your model.\n\nExplanation:\n- Feature attribution skew and drift detection is the best way to detect model performance changes in production when the input data distribution might change over time.\n- Training-serving skew detection is not relevant because the model is not being trained in the cloud.\n- Feature-based explanations and example-based explanations are not relevant because they are used for understanding model predictions, not for detecting model performance changes."
    },
    {
        "Question": "You work for a retail company that is using a regression model built with BigQuery ML to predict product sales. This model is being used to serve online predictions. Recently you developed a new version of the model that uses a different architecture (custom model). Initial analysis revealed that both models are performing as expected. You want to deploy the new version of the model to production and monitor the performance over the next two months. You need to minimize the impact to the existing and future model users. How should you deploy the model?",
        "Possible answers": "A)Import the new model to the same Vertex AI Model Registry as a different version of the existing model. Deploy the new model to the same Vertex AI endpoint as the existing model, and use traffic splitting to route 95% of production traffic to the BigQuery ML model and 5% of production traffic to the new model.\nB)Import the new model to the same Vertex AI Model Registry as the existing model. Deploy the models to one Vertex AI endpoint. Route 95% of production traffic to the BigQuery ML model and 5% of production traffic to the new model.\nC)Import the new model to the same Vertex AI Model Registry as the existing model. Deploy each model to a separate Vertex AI endpoint.\nD)Deploy the new model to a separate Vertex AI endpoint. Create a Cloud Run service that routes the prediction requests to the corresponding endpoints based on the input feature values.,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n Explanation:\n- Option B allows for easy traffic splitting between the two models, allowing for gradual migration and monitoring of the new model's performance.\n- Option A is incorrect because it doesn't allow for traffic splitting between the two models.\n- Option C is incorrect because it requires maintaining two separate endpoints, which can be more complex and difficult to manage.\n- Option D is incorrect because it introduces additional complexity with the Cloud Run service and requires custom logic for routing requests based on feature values."
    },
    {
        "Question": "You work for an organization that operates a streaming music service. You have a custom production model that is serving a “next song” recommendation based on a user's recent listening history. Your model is deployed on a Vertex AI endpoint. You recently retrained the same model by using fresh data. The model received positive test results offline. You now want to test the new model in production while minimizing complexity. What should you do?",
        "Possible answers": "A)Create a new Vertex AI endpoint for the new model and deploy the new model to that new endpoint. Build a service to randomly send 5% of production traffic to the new endpoint. Monitor end-user metrics such as listening time. If end-user metrics improve between models over time, gradually increase the percentage of production traffic sent to the new endpoint.\nB)Capture incoming prediction requests in BigQuery. Create an experiment in Vertex AI Experiments. Run batch predictions for both models using the captured data. Use the user’s selected song to compare the models performance side by side. If the new model’s performance metrics are better than the previous model, deploy the new model to production.\nC)Deploy the new model to the existing Vertex AI endpoint. Use traffic splitting to send 5% of production traffic to the new model. Monitor end-user metrics, such as listening time. If end-user metrics improve between models over time, gradually increase the percentage of production traffic sent to the new model.\nD)Configure a model monitoring job for the existing Vertex AI endpoint. Configure the monitoring job to detect prediction drift and set a threshold for alerts. Update the model on the endpoint from the previous model to the new model. If you receive an alert of prediction drift, revert to the previous model.,",
        "Correct answer & Explanation": "Correct Answer:\nC\n\nExplanation:\n Explanation:\n- Option C is the best choice because it allows for a gradual rollout of the new model, with the ability to monitor end-user metrics and gradually increase the percentage of production traffic sent to the new model if it performs better than the previous model.\n- Option A is not as good because it requires building a new service to randomly send 5% of production traffic to the new endpoint, which adds complexity to the system.\n- Option B is not as good because it requires capturing incoming prediction requests in BigQuery and running batch predictions for both models, which can be time-consuming and may not be necessary if the new model performs better than the previous model in production.\n- Option D is not as good because it relies on model monitoring to detect prediction drift, which may not be as effective as directly monitoring end-user metrics. Additionally, reverting to the previous model if prediction drift is detected may not be necessary if the new model performs better than the previous model in production."
    },
    {
        "Question": "You have trained an XGBoost model that you plan to deploy on Vertex AI for online prediction. You are now uploading your model to Vertex AI Model Registry, and you need to configure the explanation method that will serve online prediction requests to be returned with minimal latency. You also want to be alerted when feature attributions of the model meaningfully change over time. What should you do?",
        "Possible answers": "A)1. Specify sampled Shapley as the explanation method with a path count of 5. 2. Deploy the model to Vertex AI Endpoints. 3. Create a Model Monitoring job that uses prediction drift as the monitoring objective.\nB)1. Specify Integrated Gradients as the explanation method with a path count of 5. 2. Deploy the model to Vertex AI Endpoints. 3. Create a Model Monitoring job that uses prediction drift as the monitoring objective.\nC)1. Specify sampled Shapley as the explanation method with a path count of 50. 2. Deploy the model to Vertex AI Endpoints. 3. Create a Model Monitoring job that uses training-serving skew as the monitoring objective.\nD)1. Specify Integrated Gradients as the explanation method with a path count of 50. 2. Deploy the model to Vertex AI Endpoints. 3. Create a Model Monitoring job that uses training-serving skew as the monitoring objective.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n - Sampled Shapley is a faster explanation method compared to Integrated Gradients, making it suitable for low-latency online prediction requests.\n- A lower path count, such as 5, reduces the computational cost of generating explanations, further minimizing latency.\n- Prediction drift is a suitable monitoring objective for detecting changes in model behavior over time, as it compares predictions made by the deployed model with those made during training.\n- Training-serving skew is not relevant in this scenario as it compares training data with predictions made by the deployed model, which is not applicable for online prediction."
    },
    {
        "Question": "You recently trained an XGBoost model on tabular data. You plan to expose the model for internal use as an HTTP microservice. After deployment, you expect a small number of incoming requests. You want to productionize the model with the least amount of effort and latency. What should you do?",
        "Possible answers": "A)Deploy the model to BigQuery ML by using CREATE MODEL with the BOOSTED_TREE_REGRESSOR statement, and invoke the BigQuery API from the microservice.\nB)Build a Flask-based app. Package the app in a custom container on Vertex AI, and deploy it to Vertex AI Endpoints.\nC)Build a Flask-based app. Package the app in a Docker image, and deploy it to Google Kubernetes Engine in Autopilot mode.\nD)Use a prebuilt XGBoost Vertex container to create a model, and deploy it to Vertex AI Endpoints.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n Explanation:\n- Prebuilt XGBoost container is the easiest way to deploy XGBoost models to Vertex AI Endpoints.\n- BigQuery ML doesn't support XGBoost models.\n- Vertex AI Endpoints is a fully managed service, so it requires less effort to deploy and manage models compared to deploying models to Kubernetes Engine."
    },
    {
        "Question": "You work at a bank. You need to develop a credit risk model to support loan application decisions. You decide to implement the model by using a neural network in TensorFlow. Due to regulatory requirements, you need to be able to explain the model’s predictions based on its features. When the model is deployed, you also want to monitor the model’s performance over time. You decided to use Vertex AI for both model development and deployment. What should you do?",
        "Possible answers": "A)Use Vertex Explainable AI with the sampled Shapley method, and enable Vertex AI Model Monitoring to check for feature distribution drift.\nB)Use Vertex Explainable AI with the sampled Shapley method, and enable Vertex AI Model Monitoring to check for feature distribution skew.\nC)Use Vertex Explainable AI with the XRAI method, and enable Vertex AI Model Monitoring to check for feature distribution drift.\nD)Use Vertex Explainable AI with the XRAI method, and enable Vertex AI Model Monitoring to check for feature distribution skew.,",
        "Correct answer & Explanation": "Correct Answer:\nA\n\nExplanation:\n The sampled Shapley method is the recommended method for explaining the predictions of neural networks, as it provides a more accurate representation of the feature importance. Feature distribution drift is a more common problem than feature distribution skew, so it is more important to monitor for drift."
    },
    {
        "Question": "You need to deploy a scikit-leam classification model to production. The model must be able to serve requests 24/7, and you expect millions of requests per second to the production application from 8 am to 7 pm. You need to minimize the cost of deployment. What should you do?",
        "Possible answers": "A)Deploy an online Vertex AI prediction endpoint. Set the max replica count to 1\nB)Deploy an online Vertex AI prediction endpoint. Set the max replica count to 100\nC)Deploy an online Vertex AI prediction endpoint with one GPU per replica. Set the max replica count to 1\nD)Deploy an online Vertex AI prediction endpoint with one GPU per replica. Set the max replica count to 100,",
        "Correct answer & Explanation": "Correct Answer:\nB\n\nExplanation:\n - The model is a scikit-learn model, so it doesn't need a GPU.\n- The expected number of requests per second is very high, so you need to set the max replica count to a high value.\n- Option B sets the max replica count to 100/n, which is the recommended value for scikit-learn models."
    },
    {
        "Question": "You developed a custom model by using Vertex AI to forecast the sales of your company’s products based on historical transactional data. You anticipate changes in the feature distributions and the correlations between the features in the near future. You also expect to receive a large volume of prediction requests. You plan to use Vertex AI Model Monitoring for drift detection and you want to minimize the cost. What should you do?",
        "Possible answers": "A)Use the features for monitoring. Set a monitoring-frequency value that is higher than the default.\nB)Use the features for monitoring. Set a prediction-sampling-rate value that is closer to 1 than 0.\nC)Use the features and the feature attributions for monitoring. Set a monitoring-frequency value that is lower than the default.\nD)Use the features and the feature attributions for monitoring. Set a prediction-sampling-rate value that is closer to 0 than 1.,",
        "Correct answer & Explanation": "Correct Answer:\nD\n\nExplanation:\n - Feature attributions are more sensitive to drift than features\n- Lower prediction-sampling-rate means less predictions are sampled, which reduces cost"
    }
]